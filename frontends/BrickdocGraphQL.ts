import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
const defaultOptions = {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** AutoIncrement Primary Key */
  AutoIncrementID: string
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: any
  /** Email Address */
  Email: string
  /** A valid http/https url or image uri */
  HttpUrl: string
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any
  /** Represents untyped JSON */
  JSON: any
  /** UUID V4 */
  UUID: string
}

/** Available authentication authentication. */
export enum AuthMethod {
  /** Email and Password Authentication */
  EmailPassword = 'email_password',
  /** Github Federated Authentication */
  Github = 'github'
}

export type AuthorizationResult = {
  __typename?: 'AuthorizationResult'
  /** Human-readable error message */
  message?: Maybe<Scalars['String']>
  /** Reasons of check failure */
  reasons?: Maybe<FailureReasons>
  /** Result of applying a policy rule */
  value: Scalars['Boolean']
}

export type BlockAttachment = {
  __typename?: 'BlockAttachment'
  /** height */
  height?: Maybe<Scalars['Int']>
  /** url or blob key */
  key: Scalars['String']
  /** type */
  source: Filesourcetype
  /** type */
  type: Blocktype
  /** width */
  width?: Maybe<Scalars['Int']>
}

export type BlockBaseObjectPermissions = {
  __typename?: 'BlockBaseObjectPermissions'
  canShow: AuthorizationResult
}

export type BlockColor = {
  __typename?: 'BlockColor'
  /** string */
  color: Scalars['String']
  /** type */
  type: Blocktype
}

/** GraphQL */
export type BlockCover = BlockColor | BlockImage

/** Autogenerated input type of BlockCreateShareLink */
export type BlockCreateShareLinkInput = {
  /** block unique id */
  id: Scalars['UUID']
  /** policy */
  policy: Policytype
  /** share type */
  shareType: Sharetype
  /** expired time */
  expiredAt?: Maybe<Scalars['ISO8601DateTime']>
  /** webid */
  webids?: Maybe<Array<Scalars['String']>>
  /** email */
  emails?: Maybe<Array<Scalars['Email']>>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of BlockCreateShareLink */
export type BlockCreateShareLinkPayload = {
  __typename?: 'BlockCreateShareLinkPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  shareLink?: Maybe<ShareLink>
}

/** Autogenerated input type of BlockCreateSnapshot */
export type BlockCreateSnapshotInput = {
  /** block unique id */
  id: Scalars['UUID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of BlockCreateSnapshot */
export type BlockCreateSnapshotPayload = {
  __typename?: 'BlockCreateSnapshotPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of BlockCreateSubBlock */
export type BlockCreateSubBlockInput = {
  /** block id */
  id: Scalars['UUID']
  /** title */
  title: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of BlockCreateSubBlock */
export type BlockCreateSubBlockPayload = {
  __typename?: 'BlockCreateSubBlockPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of BlockDelete */
export type BlockDeleteInput = {
  /** block unique id */
  id: Scalars['UUID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of BlockDelete */
export type BlockDeletePayload = {
  __typename?: 'BlockDeletePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export type BlockEmoji = {
  __typename?: 'BlockEmoji'
  /** emoji */
  emoji: Scalars['String']
  /** name */
  name: Scalars['String']
  /** type */
  type: Blocktype
}

export type BlockHistory = {
  __typename?: 'BlockHistory'
  /** History version */
  historyVersion: Scalars['Int']
  /** object unique id */
  id: Scalars['AutoIncrementID']
}

/** GraphQL */
export type BlockIcon = BlockEmoji | BlockImage

export type BlockImage = {
  __typename?: 'BlockImage'
  /** height */
  height?: Maybe<Scalars['Int']>
  /** key */
  key: Scalars['String']
  /** aspect ratio */
  ratio?: Maybe<Scalars['Float']>
  /** type */
  source: Filesourcetype
  /** type */
  type: Blocktype
  /** width */
  width?: Maybe<Scalars['Int']>
}

/** InputObject type of Class */
export type BlockInput = {
  /** block unique id */
  id: Scalars['UUID']
  /** block type */
  type: Scalars['String']
  /** parent uuid */
  parentId?: Maybe<Scalars['UUID']>
  /** block sort */
  sort?: Maybe<Scalars['BigInt']>
  /** content */
  content: Array<Scalars['JSON']>
  /** text */
  text: Scalars['String']
  /** data */
  data?: Maybe<Scalars['JSON']>
  /** meta */
  meta?: Maybe<Scalars['JSON']>
  /** attachments */
  attachments?: Maybe<Array<Scalars['String']>>
}

export type BlockMeta = {
  __typename?: 'BlockMeta'
  /** attachment */
  attachment?: Maybe<BlockAttachment>
  /** cover */
  cover?: Maybe<BlockCover>
  /** icon */
  icon?: Maybe<BlockIcon>
  /** image */
  image?: Maybe<BlockImage>
  /** Prosemirror builtin level */
  level?: Maybe<Scalars['Int']>
  /** title */
  title?: Maybe<Scalars['String']>
}

/** Autogenerated input type of BlockMove */
export type BlockMoveInput = {
  /** block unique id */
  id: Scalars['UUID']
  /** target parent id */
  targetParentId?: Maybe<Scalars['UUID']>
  /** block sort */
  sort: Scalars['BigInt']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of BlockMove */
export type BlockMovePayload = {
  __typename?: 'BlockMovePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export type BlockSnapshot = {
  __typename?: 'BlockSnapshot'
  /** object unique id */
  id: Scalars['AutoIncrementID']
  /** Snapshot name */
  name: Scalars['String']
  /** Snapshot version */
  snapshotVersion: Scalars['Int']
}

/** Autogenerated input type of BlockSyncBatch */
export type BlockSyncBatchInput = {
  blocks: Array<BlockInput>
  /** block root id */
  rootId: Scalars['UUID']
  /** operator id */
  operatorId: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of BlockSyncBatch */
export type BlockSyncBatchPayload = {
  __typename?: 'BlockSyncBatchPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export enum Blocktype {
  /** IMAGE */
  Image = 'IMAGE',
  /** EMOJI */
  Emoji = 'EMOJI',
  /** COLOR */
  Color = 'COLOR',
  /** ATTACHMENT */
  Attachment = 'ATTACHMENT'
}

/** Autogenerated input type of CreateDirectUpload */
export type CreateDirectUploadInput = {
  input: DirectUploadInput
  type: Upload
  /** block id */
  blockId?: Maybe<Scalars['UUID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of CreateDirectUpload */
export type CreateDirectUploadPayload = {
  __typename?: 'CreateDirectUploadPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  directUpload: DirectUpload
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of CreateOrUpdatePod */
export type CreateOrUpdatePodInput = {
  /** webid */
  webid: Scalars['String']
  type: PodOperation
  /** pod name */
  name: Scalars['String']
  /** bio */
  bio?: Maybe<Scalars['String']>
  /** Avatar signed id */
  avatarSignedId?: Maybe<Scalars['String']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of CreateOrUpdatePod */
export type CreateOrUpdatePodPayload = {
  __typename?: 'CreateOrUpdatePodPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  pod?: Maybe<Pod>
}

/** Represents direct upload credentials */
export type DirectUpload = {
  __typename?: 'DirectUpload'
  /** Created blob record key */
  blobKey: Scalars['String']
  /** HTTP request headers (JSON-encoded) */
  headers: Scalars['JSON']
  /** Blob signed id */
  signedId: Scalars['String']
  /** Upload URL */
  uploadUrl: Scalars['String']
  /** View url */
  viewUrl: Scalars['String']
}

/** File information required to prepare a direct upload */
export type DirectUploadInput = {
  /** Original file name */
  filename: Scalars['String']
  /** File size (bytes) */
  byteSize: Scalars['Int']
  /** MD5 file checksum as base64 */
  checksum: Scalars['String']
  /** File content type */
  contentType: Scalars['String']
  /** metadata */
  metadata?: Maybe<Scalars['JSON']>
}

export type FailureReasons = {
  __typename?: 'FailureReasons'
  /** JSON-encoded map of reasons */
  details: Scalars['String']
  /** Human-readable errors */
  fullMessages: Array<Scalars['String']>
}

export enum Filesourcetype {
  /** ORIGIN */
  Origin = 'ORIGIN',
  /** EXTERNAL */
  External = 'EXTERNAL'
}

/** Autogenerated return type of NewPatch */
export type NewPatchPayload = {
  __typename?: 'NewPatchPayload'
  patches: Array<PatchBaseObject>
  seq: Scalars['Int']
  state: Patchstate
}

export type PatchBaseObject = {
  __typename?: 'PatchBaseObject'
  id: Scalars['UUID']
  operatorId: Scalars['String']
  patchType: Patchtype
  path: Array<Scalars['UUID']>
  payload: Scalars['JSON']
}

export enum Patchstate {
  /** DELETED */
  Deleted = 'DELETED',
  /** ACTIVE */
  Active = 'ACTIVE',
  /** SUBSCRIBED */
  Subscribed = 'SUBSCRIBED'
}

export enum Patchtype {
  /** ADD */
  Add = 'ADD',
  /** UPDATE */
  Update = 'UPDATE',
  /** DELETE */
  Delete = 'DELETE'
}

/** Pod operation types */
export enum PodOperation {
  /** CREATE */
  Create = 'CREATE',
  /** UPDATE */
  Update = 'UPDATE'
}

export enum Policytype {
  /** SHOW */
  Show = 'SHOW'
}

export type RootMutation = {
  __typename?: 'RootMutation'
  blockCreateShareLink?: Maybe<BlockCreateShareLinkPayload>
  blockCreateSnapshot?: Maybe<BlockCreateSnapshotPayload>
  blockCreateSubBlock?: Maybe<BlockCreateSubBlockPayload>
  blockDelete?: Maybe<BlockDeletePayload>
  blockMove?: Maybe<BlockMovePayload>
  blockSyncBatch?: Maybe<BlockSyncBatchPayload>
  createDirectUpload?: Maybe<CreateDirectUploadPayload>
  createOrUpdatePod?: Maybe<CreateOrUpdatePodPayload>
  /**
   *
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  userConfirmationEmailResend?: Maybe<UserConfirmationEmailResendPayload>
  /**
   *
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  userCreate?: Maybe<UserCreatePayload>
  /**
   *
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  userEmailPasswordSignIn?: Maybe<UserEmailPasswordSignInPayload>
  /**
   *
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  userForgetPasswordMailSend?: Maybe<UserForgetPasswordMailSendPayload>
  /**
   *
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  userPasswordReset?: Maybe<UserPasswordResetPayload>
  /**
   *
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  userSignOut?: Maybe<UserSignOutPayload>
}

export type RootMutationBlockCreateShareLinkArgs = {
  input: BlockCreateShareLinkInput
}

export type RootMutationBlockCreateSnapshotArgs = {
  input: BlockCreateSnapshotInput
}

export type RootMutationBlockCreateSubBlockArgs = {
  input: BlockCreateSubBlockInput
}

export type RootMutationBlockDeleteArgs = {
  input: BlockDeleteInput
}

export type RootMutationBlockMoveArgs = {
  input: BlockMoveInput
}

export type RootMutationBlockSyncBatchArgs = {
  input: BlockSyncBatchInput
}

export type RootMutationCreateDirectUploadArgs = {
  input: CreateDirectUploadInput
}

export type RootMutationCreateOrUpdatePodArgs = {
  input: CreateOrUpdatePodInput
}

export type RootMutationUserConfirmationEmailResendArgs = {
  input: UserConfirmationEmailResendInput
}

export type RootMutationUserCreateArgs = {
  input: UserCreateInput
}

export type RootMutationUserEmailPasswordSignInArgs = {
  input: UserEmailPasswordSignInInput
}

export type RootMutationUserForgetPasswordMailSendArgs = {
  input: UserForgetPasswordMailSendInput
}

export type RootMutationUserPasswordResetArgs = {
  input: UserPasswordResetInput
}

export type RootMutationUserSignOutArgs = {
  input: UserSignOutInput
}

export type RootQuery = {
  __typename?: 'RootQuery'
  /** return single block by id. */
  block?: Maybe<Block>
  /** return histories by block id. */
  blockHistories?: Maybe<Array<BlockHistory>>
  /** return snapshots by block id. */
  blockSnapshots?: Maybe<Array<BlockSnapshot>>
  childrenBlocks?: Maybe<Array<Block>>
  /**
   * Check email available.
   * Required `context[:entrypoints]` is `[:internal]`.
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  emailAvailable: Validate_Result
  /**
   * provides a federated identity session data
   * Required `context[:entrypoints]` is `[:internal]`.
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  federatedIdentitySession: OmniauthSession
  /** Return information about current Brickdoc server instance. */
  metadata: Metadata
  pageBlocks?: Maybe<Array<Block>>
  /**
   * Check password available.
   * Required `context[:entrypoints]` is `[:internal]`.
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  passwordAvailable: Validate_Result
  /** return all pods for user. */
  pods: Array<Pod>
  /** return images from unsplash by search */
  unsplashImage?: Maybe<Array<Unsplash_Image>>
  /**
   * Check webid available.
   * Required `context[:entrypoints]` is `[:internal]`.
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  webidAvailable: Validate_Result
}

export type RootQueryBlockArgs = {
  id: Scalars['String']
}

export type RootQueryBlockHistoriesArgs = {
  id: Scalars['String']
}

export type RootQueryBlockSnapshotsArgs = {
  id: Scalars['String']
}

export type RootQueryChildrenBlocksArgs = {
  rootId: Scalars['String']
  snapshotVersion: Scalars['Int']
}

export type RootQueryEmailAvailableArgs = {
  email: Scalars['String']
}

export type RootQueryPageBlocksArgs = {
  webid: Scalars['String']
}

export type RootQueryPasswordAvailableArgs = {
  password: Scalars['String']
}

export type RootQueryUnsplashImageArgs = {
  query?: Maybe<Scalars['String']>
  page?: Maybe<Scalars['Int']>
  perPage?: Maybe<Scalars['Int']>
}

export type RootQueryWebidAvailableArgs = {
  webid: Scalars['String']
}

export type RootSubscription = {
  __typename?: 'RootSubscription'
  newPatch: NewPatchPayload
}

export type RootSubscriptionNewPatchArgs = {
  docId: Scalars['UUID']
}

export type ShareLink = {
  __typename?: 'ShareLink'
  key: Scalars['String']
}

export enum Sharetype {
  /** POD */
  Pod = 'POD',
  /** USER */
  User = 'USER',
  /** EVERYONE */
  Everyone = 'EVERYONE',
  /** ANONYMOUS */
  Anonymous = 'ANONYMOUS'
}

/** Upload types */
export enum Upload {
  /** Account avatar */
  Avatar = 'AVATAR',
  /** Page block */
  Doc = 'DOC',
  /** Third */
  Third = 'THIRD'
}

/** Autogenerated input type of UserConfirmationEmailResend */
export type UserConfirmationEmailResendInput = {
  /** User's email address */
  email: Scalars['Email']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserConfirmationEmailResend */
export type UserConfirmationEmailResendPayload = {
  __typename?: 'UserConfirmationEmailResendPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of UserCreate */
export type UserCreateInput = {
  /** Like a username, Unique within this instance of Brickdoc. */
  webid: Scalars['String']
  /** Human-readable name of the user */
  name: Scalars['String']
  /** User's email address */
  email?: Maybe<Scalars['Email']>
  /** user password */
  password?: Maybe<Scalars['String']>
  /** User's preferred language */
  locale: Scalars['String']
  /** User's preferred timezone */
  timezone: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserCreate */
export type UserCreatePayload = {
  __typename?: 'UserCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  isUserActive?: Maybe<Scalars['Boolean']>
  /** redirect url path when sig up successful */
  redirectPath?: Maybe<Scalars['String']>
}

/** Autogenerated input type of UserEmailPasswordSignIn */
export type UserEmailPasswordSignInInput = {
  /** User's email address */
  email: Scalars['Email']
  /** user password */
  password: Scalars['String']
  /** remember authentication session */
  remember: Scalars['Boolean']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserEmailPasswordSignIn */
export type UserEmailPasswordSignInPayload = {
  __typename?: 'UserEmailPasswordSignInPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  /** redirect url path when sign in successful */
  redirectPath?: Maybe<Scalars['String']>
}

/** Autogenerated input type of UserForgetPasswordMailSend */
export type UserForgetPasswordMailSendInput = {
  /** User's email address */
  email: Scalars['Email']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserForgetPasswordMailSend */
export type UserForgetPasswordMailSendPayload = {
  __typename?: 'UserForgetPasswordMailSendPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of UserPasswordReset */
export type UserPasswordResetInput = {
  /** Reset password token by Devise */
  token: Scalars['String']
  /** Reset password */
  password: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserPasswordReset */
export type UserPasswordResetPayload = {
  __typename?: 'UserPasswordResetPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of UserSignOut */
export type UserSignOutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserSignOut */
export type UserSignOutPayload = {
  __typename?: 'UserSignOutPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** A user is an individual's accounts on Brickdoc can make new content. */
export type Accounts_User = {
  __typename?: 'accounts_user'
  /** the user's public profile bio */
  bio?: Maybe<Scalars['String']>
  /** User's email address */
  email?: Maybe<Scalars['String']>
  /** object unique id */
  id: Scalars['AutoIncrementID']
  /** User's preferred language */
  locale: Scalars['String']
  /** Human-readable name of the user */
  name: Scalars['String']
  /** User's preferred timezone */
  timezone: Scalars['String']
  /** Like a username, Unique within this instance of Brickdoc. */
  webid: Scalars['String']
}

export type Avatar = {
  __typename?: 'avatar'
  /** signed id */
  signedId: Scalars['String']
  /** url */
  url: Scalars['String']
}

/** ActiveStorage blobs */
export type Blob = {
  __typename?: 'blob'
  /** Blob key */
  blobKey: Scalars['String']
  /** Blob url */
  url: Scalars['String']
}

/** Brickdoc Docs::Block */
export type Block = {
  __typename?: 'block'
  /** blobs */
  blobs?: Maybe<Array<Blob>>
  /** collaborators */
  collaborators?: Maybe<Array<Accounts_User>>
  /** content */
  content: Array<Scalars['JSON']>
  data: Scalars['JSON']
  /** block first child sort */
  firstChildSort: Scalars['BigInt']
  /** object unique id */
  id: Scalars['UUID']
  meta: BlockMeta
  /** block next sort */
  nextSort: Scalars['BigInt']
  /** parent uuid */
  parentId?: Maybe<Scalars['UUID']>
  permissions: BlockBaseObjectPermissions
  /** root uuid */
  rootId: Scalars['UUID']
  /** block sort */
  sort: Scalars['BigInt']
  /** text */
  text: Scalars['String']
  /** block type */
  type: Scalars['String']
}

/** Brickdoc Global Configuration */
export type Config = {
  __typename?: 'config'
  /** Enable email and password authentication */
  accountsEmailPasswordAuth: Scalars['Boolean']
  /** Enabled federated identity providers */
  accountsFederatedProviders: Array<FederatedProvider>
  /** Preferred Authentication authentication */
  accountsPreferredAuthMethod: AuthMethod
  /** User agreement link */
  userAgreementLink: Scalars['HttpUrl']
}

/** Accounts Federated Identity Provide Configuration */
export type FederatedProvider = {
  __typename?: 'federatedProvider'
  /** Provider Logo URI */
  logo: Scalars['HttpUrl']
  /** Provider Name */
  name: Scalars['String']
}

/** Represents information about the Brickdoc Server Instance. */
export type Metadata = {
  __typename?: 'metadata'
  /** Current available locales. */
  availableLocales: Array<Select_Option>
  /** Brickdoc Global Config */
  config: Config
  /** object unique id */
  id: Scalars['AutoIncrementID']
}

/** session[:omniauth] */
export type OmniauthSession = {
  __typename?: 'omniauthSession'
  hasSession: Scalars['Boolean']
  /** Human-readable name of the user */
  name?: Maybe<Scalars['String']>
  /** Provider Name */
  provider?: Maybe<Scalars['String']>
  /** Like a username, Unique within this instance of Brickdoc. */
  webid?: Maybe<Scalars['String']>
}

/** Brickdoc Pod. */
export type Pod = {
  __typename?: 'pod'
  /** Pod Avatar */
  avatarData?: Maybe<Avatar>
  /** public profile bio */
  bio?: Maybe<Scalars['String']>
  /** object unique id */
  id: Scalars['AutoIncrementID']
  /** Pod Name */
  name?: Maybe<Scalars['String']>
  /** Like a username, Unique within this instance of Brickdoc */
  webid: Scalars['String']
}

/** Option Object for BrickDesign Select Component. */
export type Select_Option = {
  __typename?: 'select_option'
  /** option label */
  label: Scalars['String']
  /** option value */
  value: Scalars['String']
}

/** Unspash image. */
export type Unsplash_Image = {
  __typename?: 'unsplash_image'
  /** url for full size image */
  fullUrl: Scalars['String']
  /** Image height */
  height?: Maybe<Scalars['Int']>
  /** Unsplash image id */
  id: Scalars['String']
  /** url for small size image */
  smallUrl: Scalars['String']
  /** username */
  username?: Maybe<Scalars['String']>
  /** Image width */
  width?: Maybe<Scalars['Int']>
}

export type Validate_Result = {
  __typename?: 'validate_result'
  /** error message */
  message: Scalars['String']
  /** Validate success */
  success: Scalars['Boolean']
}

export type UserSignOutMutationVariables = Exact<{
  input: UserSignOutInput
}>

export type UserSignOutMutation = {
  __typename?: 'RootMutation'
  userSignOut?: Maybe<{ __typename?: 'UserSignOutPayload'; errors: Array<string> }>
}

export type GetAccountsConfigFromWsQueryVariables = Exact<{ [key: string]: never }>

export type GetAccountsConfigFromWsQuery = {
  __typename?: 'RootQuery'
  metadata: {
    __typename?: 'metadata'
    id: string
    config: {
      __typename?: 'config'
      userAgreementLink: string
      accountsPreferredAuthMethod: AuthMethod
      accountsEmailPasswordAuth: boolean
      accountsFederatedProviders: Array<{ __typename?: 'federatedProvider'; name: string; logo: string }>
    }
  }
}

export type UserForgetPasswordMailSendMutationVariables = Exact<{
  input: UserForgetPasswordMailSendInput
}>

export type UserForgetPasswordMailSendMutation = {
  __typename?: 'RootMutation'
  userForgetPasswordMailSend?: Maybe<{ __typename?: 'UserForgetPasswordMailSendPayload'; errors: Array<string> }>
}

export type UserPasswordResetMutationVariables = Exact<{
  input: UserPasswordResetInput
}>

export type UserPasswordResetMutation = {
  __typename?: 'RootMutation'
  userPasswordReset?: Maybe<{ __typename?: 'UserPasswordResetPayload'; errors: Array<string> }>
}

export type UserEmailPasswordSignInMutationVariables = Exact<{
  input: UserEmailPasswordSignInInput
}>

export type UserEmailPasswordSignInMutation = {
  __typename?: 'RootMutation'
  userEmailPasswordSignIn?: Maybe<{ __typename?: 'UserEmailPasswordSignInPayload'; errors: Array<string>; redirectPath?: Maybe<string> }>
}

export type GetFederatedIdentitySessionQueryVariables = Exact<{ [key: string]: never }>

export type GetFederatedIdentitySessionQuery = {
  __typename?: 'RootQuery'
  federatedIdentitySession: {
    __typename?: 'omniauthSession'
    hasSession: boolean
    webid?: Maybe<string>
    name?: Maybe<string>
    provider?: Maybe<string>
  }
}

export type UserCreateMutationVariables = Exact<{
  input: UserCreateInput
}>

export type UserCreateMutation = {
  __typename?: 'RootMutation'
  userCreate?: Maybe<{
    __typename?: 'UserCreatePayload'
    errors: Array<string>
    redirectPath?: Maybe<string>
    isUserActive?: Maybe<boolean>
  }>
}

export type UserConfirmationEmailResendMutationVariables = Exact<{
  input: UserConfirmationEmailResendInput
}>

export type UserConfirmationEmailResendMutation = {
  __typename?: 'RootMutation'
  userConfirmationEmailResend?: Maybe<{ __typename?: 'UserConfirmationEmailResendPayload'; errors: Array<string> }>
}

export type QueryEmailAvailableFromWsQueryVariables = Exact<{
  email: Scalars['String']
}>

export type QueryEmailAvailableFromWsQuery = {
  __typename?: 'RootQuery'
  emailAvailable: { __typename?: 'validate_result'; success: boolean; message: string }
}

export type QueryPasswordAvailableFromWsQueryVariables = Exact<{
  password: Scalars['String']
}>

export type QueryPasswordAvailableFromWsQuery = {
  __typename?: 'RootQuery'
  passwordAvailable: { __typename?: 'validate_result'; success: boolean; message: string }
}

export type QueryWebidAvailableFromWsQueryVariables = Exact<{
  webid: Scalars['String']
}>

export type QueryWebidAvailableFromWsQuery = {
  __typename?: 'RootQuery'
  webidAvailable: { __typename?: 'validate_result'; success: boolean; message: string }
}

export type GetAvailableLocalesFromWsQueryVariables = Exact<{ [key: string]: never }>

export type GetAvailableLocalesFromWsQuery = {
  __typename?: 'RootQuery'
  metadata: { __typename?: 'metadata'; id: string; availableLocales: Array<{ __typename?: 'select_option'; label: string; value: string }> }
}

export type CreateDirectUploadMutationVariables = Exact<{
  input: CreateDirectUploadInput
}>

export type CreateDirectUploadMutation = {
  __typename?: 'RootMutation'
  createDirectUpload?: Maybe<{
    __typename?: 'CreateDirectUploadPayload'
    directUpload: { __typename?: 'DirectUpload'; uploadUrl: string; headers: any; blobKey: string; viewUrl: string; signedId: string }
  }>
}

export type GetPodsQueryVariables = Exact<{ [key: string]: never }>

export type GetPodsQuery = {
  __typename?: 'RootQuery'
  pods: Array<{
    __typename?: 'pod'
    id: string
    webid: string
    name?: Maybe<string>
    bio?: Maybe<string>
    avatarData?: Maybe<{ __typename?: 'avatar'; url: string; signedId: string }>
  }>
}

export type QueryUnsplashImageQueryVariables = Exact<{
  query?: Maybe<Scalars['String']>
  page?: Maybe<Scalars['Int']>
  perPage?: Maybe<Scalars['Int']>
}>

export type QueryUnsplashImageQuery = {
  __typename?: 'RootQuery'
  unsplashImage?: Maybe<
    Array<{
      __typename?: 'unsplash_image'
      id: string
      width?: Maybe<number>
      height?: Maybe<number>
      fullUrl: string
      smallUrl: string
      username?: Maybe<string>
    }>
  >
}

export type CreateOrUpdatePodMutationVariables = Exact<{
  input: CreateOrUpdatePodInput
}>

export type CreateOrUpdatePodMutation = {
  __typename?: 'RootMutation'
  createOrUpdatePod?: Maybe<{
    __typename?: 'CreateOrUpdatePodPayload'
    errors: Array<string>
    pod?: Maybe<{ __typename?: 'pod'; webid: string; name?: Maybe<string> }>
  }>
}

export type GetPageBlocksQueryVariables = Exact<{
  webid: Scalars['String']
}>

export type GetPageBlocksQuery = {
  __typename?: 'RootQuery'
  pageBlocks?: Maybe<
    Array<{
      __typename?: 'block'
      id: string
      sort: any
      nextSort: any
      firstChildSort: any
      rootId: string
      parentId?: Maybe<string>
      type: string
      text: string
      content: Array<any>
      data: any
      meta: {
        __typename?: 'BlockMeta'
        cover?: Maybe<
          | { __typename?: 'BlockColor'; type: Blocktype; color: string }
          | { __typename?: 'BlockImage'; type: Blocktype; source: Filesourcetype; key: string }
        >
        icon?: Maybe<
          | { __typename?: 'BlockEmoji'; type: Blocktype; name: string; emoji: string }
          | { __typename?: 'BlockImage'; type: Blocktype; source: Filesourcetype; key: string }
        >
      }
    }>
  >
}

export type GetBlockSnapshotsQueryVariables = Exact<{
  id: Scalars['String']
}>

export type GetBlockSnapshotsQuery = {
  __typename?: 'RootQuery'
  blockSnapshots?: Maybe<Array<{ __typename?: 'BlockSnapshot'; id: string; snapshotVersion: number; name: string }>>
}

export type GetBlockHistoriesQueryVariables = Exact<{
  id: Scalars['String']
}>

export type GetBlockHistoriesQuery = {
  __typename?: 'RootQuery'
  blockHistories?: Maybe<Array<{ __typename?: 'BlockHistory'; id: string; historyVersion: number }>>
}

export type BlockDeleteMutationVariables = Exact<{
  input: BlockDeleteInput
}>

export type BlockDeleteMutation = {
  __typename?: 'RootMutation'
  blockDelete?: Maybe<{ __typename?: 'BlockDeletePayload'; errors: Array<string> }>
}

export type BlockCreateSubBlockMutationVariables = Exact<{
  input: BlockCreateSubBlockInput
}>

export type BlockCreateSubBlockMutation = {
  __typename?: 'RootMutation'
  blockCreateSubBlock?: Maybe<{ __typename?: 'BlockCreateSubBlockPayload'; errors: Array<string> }>
}

export type BlockCreateShareLinkMutationVariables = Exact<{
  input: BlockCreateShareLinkInput
}>

export type BlockCreateShareLinkMutation = {
  __typename?: 'RootMutation'
  blockCreateShareLink?: Maybe<{
    __typename?: 'BlockCreateShareLinkPayload'
    errors: Array<string>
    shareLink?: Maybe<{ __typename?: 'ShareLink'; key: string }>
  }>
}

export type BlockMoveMutationVariables = Exact<{
  input: BlockMoveInput
}>

export type BlockMoveMutation = {
  __typename?: 'RootMutation'
  blockMove?: Maybe<{ __typename?: 'BlockMovePayload'; errors: Array<string> }>
}

export type BlockCreateSnapshotMutationVariables = Exact<{
  input: BlockCreateSnapshotInput
}>

export type BlockCreateSnapshotMutation = {
  __typename?: 'RootMutation'
  blockCreateSnapshot?: Maybe<{ __typename?: 'BlockCreateSnapshotPayload'; errors: Array<string> }>
}

export type BlockSyncBatchMutationVariables = Exact<{
  input: BlockSyncBatchInput
}>

export type BlockSyncBatchMutation = {
  __typename?: 'RootMutation'
  blockSyncBatch?: Maybe<{ __typename?: 'BlockSyncBatchPayload'; errors: Array<string> }>
}

export type NewPatchSubscriptionVariables = Exact<{
  docId: Scalars['UUID']
}>

export type NewPatchSubscription = {
  __typename?: 'RootSubscription'
  newPatch: {
    __typename?: 'NewPatchPayload'
    state: Patchstate
    seq: number
    patches: Array<{
      __typename?: 'PatchBaseObject'
      id: string
      path: Array<string>
      patchType: Patchtype
      payload: any
      operatorId: string
    }>
  }
}

export type GetChildrenBlocksQueryVariables = Exact<{
  rootId: Scalars['String']
  snapshotVersion: Scalars['Int']
}>

export type GetChildrenBlocksQuery = {
  __typename?: 'RootQuery'
  childrenBlocks?: Maybe<
    Array<{
      __typename?: 'block'
      id: string
      sort: any
      parentId?: Maybe<string>
      rootId: string
      type: string
      text: string
      content: Array<any>
      data: any
      blobs?: Maybe<Array<{ __typename?: 'blob'; blobKey: string; url: string }>>
      meta: {
        __typename?: 'BlockMeta'
        title?: Maybe<string>
        level?: Maybe<number>
        image?: Maybe<{
          __typename?: 'BlockImage'
          type: Blocktype
          source: Filesourcetype
          key: string
          height?: Maybe<number>
          width?: Maybe<number>
          ratio?: Maybe<number>
        }>
        attachment?: Maybe<{
          __typename?: 'BlockAttachment'
          type: Blocktype
          source: Filesourcetype
          key: string
          height?: Maybe<number>
          width?: Maybe<number>
        }>
        cover?: Maybe<
          | { __typename?: 'BlockColor'; type: Blocktype; color: string }
          | {
              __typename?: 'BlockImage'
              type: Blocktype
              source: Filesourcetype
              key: string
              height?: Maybe<number>
              width?: Maybe<number>
            }
        >
        icon?: Maybe<
          | { __typename?: 'BlockEmoji'; type: Blocktype; name: string; emoji: string }
          | {
              __typename?: 'BlockImage'
              type: Blocktype
              source: Filesourcetype
              key: string
              height?: Maybe<number>
              width?: Maybe<number>
            }
        >
      }
    }>
  >
}

export const UserSignOutDocument = gql`
  mutation userSignOut($input: UserSignOutInput!) {
    userSignOut(input: $input) {
      errors
    }
  }
`
export type UserSignOutMutationFn = Apollo.MutationFunction<UserSignOutMutation, UserSignOutMutationVariables>

/**
 * __useUserSignOutMutation__
 *
 * To run a mutation, you first call `useUserSignOutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserSignOutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userSignOutMutation, { data, loading, error }] = useUserSignOutMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserSignOutMutation(baseOptions?: Apollo.MutationHookOptions<UserSignOutMutation, UserSignOutMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserSignOutMutation, UserSignOutMutationVariables>(UserSignOutDocument, options)
}
export type UserSignOutMutationHookResult = ReturnType<typeof useUserSignOutMutation>
export type UserSignOutMutationResult = Apollo.MutationResult<UserSignOutMutation>
export type UserSignOutMutationOptions = Apollo.BaseMutationOptions<UserSignOutMutation, UserSignOutMutationVariables>
export const GetAccountsConfigFromWsDocument = gql`
  query GetAccountsConfigFromWS {
    metadata {
      id
      config {
        userAgreementLink
        accountsPreferredAuthMethod
        accountsEmailPasswordAuth
        accountsFederatedProviders {
          name
          logo
        }
      }
    }
  }
`

/**
 * __useGetAccountsConfigFromWsQuery__
 *
 * To run a query within a React component, call `useGetAccountsConfigFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAccountsConfigFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAccountsConfigFromWsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAccountsConfigFromWsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>(GetAccountsConfigFromWsDocument, options)
}
export function useGetAccountsConfigFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>(GetAccountsConfigFromWsDocument, options)
}
export type GetAccountsConfigFromWsQueryHookResult = ReturnType<typeof useGetAccountsConfigFromWsQuery>
export type GetAccountsConfigFromWsLazyQueryHookResult = ReturnType<typeof useGetAccountsConfigFromWsLazyQuery>
export type GetAccountsConfigFromWsQueryResult = Apollo.QueryResult<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>
export const UserForgetPasswordMailSendDocument = gql`
  mutation userForgetPasswordMailSend($input: UserForgetPasswordMailSendInput!) {
    userForgetPasswordMailSend(input: $input) {
      errors
    }
  }
`
export type UserForgetPasswordMailSendMutationFn = Apollo.MutationFunction<
  UserForgetPasswordMailSendMutation,
  UserForgetPasswordMailSendMutationVariables
>

/**
 * __useUserForgetPasswordMailSendMutation__
 *
 * To run a mutation, you first call `useUserForgetPasswordMailSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserForgetPasswordMailSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userForgetPasswordMailSendMutation, { data, loading, error }] = useUserForgetPasswordMailSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserForgetPasswordMailSendMutation(
  baseOptions?: Apollo.MutationHookOptions<UserForgetPasswordMailSendMutation, UserForgetPasswordMailSendMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserForgetPasswordMailSendMutation, UserForgetPasswordMailSendMutationVariables>(
    UserForgetPasswordMailSendDocument,
    options
  )
}
export type UserForgetPasswordMailSendMutationHookResult = ReturnType<typeof useUserForgetPasswordMailSendMutation>
export type UserForgetPasswordMailSendMutationResult = Apollo.MutationResult<UserForgetPasswordMailSendMutation>
export type UserForgetPasswordMailSendMutationOptions = Apollo.BaseMutationOptions<
  UserForgetPasswordMailSendMutation,
  UserForgetPasswordMailSendMutationVariables
>
export const UserPasswordResetDocument = gql`
  mutation userPasswordReset($input: UserPasswordResetInput!) {
    userPasswordReset(input: $input) {
      errors
    }
  }
`
export type UserPasswordResetMutationFn = Apollo.MutationFunction<UserPasswordResetMutation, UserPasswordResetMutationVariables>

/**
 * __useUserPasswordResetMutation__
 *
 * To run a mutation, you first call `useUserPasswordResetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPasswordResetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPasswordResetMutation, { data, loading, error }] = useUserPasswordResetMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserPasswordResetMutation(
  baseOptions?: Apollo.MutationHookOptions<UserPasswordResetMutation, UserPasswordResetMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserPasswordResetMutation, UserPasswordResetMutationVariables>(UserPasswordResetDocument, options)
}
export type UserPasswordResetMutationHookResult = ReturnType<typeof useUserPasswordResetMutation>
export type UserPasswordResetMutationResult = Apollo.MutationResult<UserPasswordResetMutation>
export type UserPasswordResetMutationOptions = Apollo.BaseMutationOptions<UserPasswordResetMutation, UserPasswordResetMutationVariables>
export const UserEmailPasswordSignInDocument = gql`
  mutation userEmailPasswordSignIn($input: UserEmailPasswordSignInInput!) {
    userEmailPasswordSignIn(input: $input) {
      errors
      redirectPath
    }
  }
`
export type UserEmailPasswordSignInMutationFn = Apollo.MutationFunction<
  UserEmailPasswordSignInMutation,
  UserEmailPasswordSignInMutationVariables
>

/**
 * __useUserEmailPasswordSignInMutation__
 *
 * To run a mutation, you first call `useUserEmailPasswordSignInMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailPasswordSignInMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailPasswordSignInMutation, { data, loading, error }] = useUserEmailPasswordSignInMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserEmailPasswordSignInMutation(
  baseOptions?: Apollo.MutationHookOptions<UserEmailPasswordSignInMutation, UserEmailPasswordSignInMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserEmailPasswordSignInMutation, UserEmailPasswordSignInMutationVariables>(
    UserEmailPasswordSignInDocument,
    options
  )
}
export type UserEmailPasswordSignInMutationHookResult = ReturnType<typeof useUserEmailPasswordSignInMutation>
export type UserEmailPasswordSignInMutationResult = Apollo.MutationResult<UserEmailPasswordSignInMutation>
export type UserEmailPasswordSignInMutationOptions = Apollo.BaseMutationOptions<
  UserEmailPasswordSignInMutation,
  UserEmailPasswordSignInMutationVariables
>
export const GetFederatedIdentitySessionDocument = gql`
  query GetFederatedIdentitySession {
    federatedIdentitySession {
      hasSession
      webid
      name
      provider
    }
  }
`

/**
 * __useGetFederatedIdentitySessionQuery__
 *
 * To run a query within a React component, call `useGetFederatedIdentitySessionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFederatedIdentitySessionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFederatedIdentitySessionQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetFederatedIdentitySessionQuery(
  baseOptions?: Apollo.QueryHookOptions<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>(
    GetFederatedIdentitySessionDocument,
    options
  )
}
export function useGetFederatedIdentitySessionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>(
    GetFederatedIdentitySessionDocument,
    options
  )
}
export type GetFederatedIdentitySessionQueryHookResult = ReturnType<typeof useGetFederatedIdentitySessionQuery>
export type GetFederatedIdentitySessionLazyQueryHookResult = ReturnType<typeof useGetFederatedIdentitySessionLazyQuery>
export type GetFederatedIdentitySessionQueryResult = Apollo.QueryResult<
  GetFederatedIdentitySessionQuery,
  GetFederatedIdentitySessionQueryVariables
>
export const UserCreateDocument = gql`
  mutation userCreate($input: UserCreateInput!) {
    userCreate(input: $input) {
      errors
      redirectPath
      isUserActive
    }
  }
`
export type UserCreateMutationFn = Apollo.MutationFunction<UserCreateMutation, UserCreateMutationVariables>

/**
 * __useUserCreateMutation__
 *
 * To run a mutation, you first call `useUserCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userCreateMutation, { data, loading, error }] = useUserCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserCreateMutation(baseOptions?: Apollo.MutationHookOptions<UserCreateMutation, UserCreateMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserCreateMutation, UserCreateMutationVariables>(UserCreateDocument, options)
}
export type UserCreateMutationHookResult = ReturnType<typeof useUserCreateMutation>
export type UserCreateMutationResult = Apollo.MutationResult<UserCreateMutation>
export type UserCreateMutationOptions = Apollo.BaseMutationOptions<UserCreateMutation, UserCreateMutationVariables>
export const UserConfirmationEmailResendDocument = gql`
  mutation userConfirmationEmailResend($input: UserConfirmationEmailResendInput!) {
    userConfirmationEmailResend(input: $input) {
      errors
    }
  }
`
export type UserConfirmationEmailResendMutationFn = Apollo.MutationFunction<
  UserConfirmationEmailResendMutation,
  UserConfirmationEmailResendMutationVariables
>

/**
 * __useUserConfirmationEmailResendMutation__
 *
 * To run a mutation, you first call `useUserConfirmationEmailResendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserConfirmationEmailResendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userConfirmationEmailResendMutation, { data, loading, error }] = useUserConfirmationEmailResendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserConfirmationEmailResendMutation(
  baseOptions?: Apollo.MutationHookOptions<UserConfirmationEmailResendMutation, UserConfirmationEmailResendMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserConfirmationEmailResendMutation, UserConfirmationEmailResendMutationVariables>(
    UserConfirmationEmailResendDocument,
    options
  )
}
export type UserConfirmationEmailResendMutationHookResult = ReturnType<typeof useUserConfirmationEmailResendMutation>
export type UserConfirmationEmailResendMutationResult = Apollo.MutationResult<UserConfirmationEmailResendMutation>
export type UserConfirmationEmailResendMutationOptions = Apollo.BaseMutationOptions<
  UserConfirmationEmailResendMutation,
  UserConfirmationEmailResendMutationVariables
>
export const QueryEmailAvailableFromWsDocument = gql`
  query QueryEmailAvailableFromWS($email: String!) {
    emailAvailable(email: $email) {
      success
      message
    }
  }
`

/**
 * __useQueryEmailAvailableFromWsQuery__
 *
 * To run a query within a React component, call `useQueryEmailAvailableFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryEmailAvailableFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryEmailAvailableFromWsQuery({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export function useQueryEmailAvailableFromWsQuery(
  baseOptions: Apollo.QueryHookOptions<QueryEmailAvailableFromWsQuery, QueryEmailAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryEmailAvailableFromWsQuery, QueryEmailAvailableFromWsQueryVariables>(
    QueryEmailAvailableFromWsDocument,
    options
  )
}
export function useQueryEmailAvailableFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryEmailAvailableFromWsQuery, QueryEmailAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryEmailAvailableFromWsQuery, QueryEmailAvailableFromWsQueryVariables>(
    QueryEmailAvailableFromWsDocument,
    options
  )
}
export type QueryEmailAvailableFromWsQueryHookResult = ReturnType<typeof useQueryEmailAvailableFromWsQuery>
export type QueryEmailAvailableFromWsLazyQueryHookResult = ReturnType<typeof useQueryEmailAvailableFromWsLazyQuery>
export type QueryEmailAvailableFromWsQueryResult = Apollo.QueryResult<
  QueryEmailAvailableFromWsQuery,
  QueryEmailAvailableFromWsQueryVariables
>
export const QueryPasswordAvailableFromWsDocument = gql`
  query QueryPasswordAvailableFromWS($password: String!) {
    passwordAvailable(password: $password) {
      success
      message
    }
  }
`

/**
 * __useQueryPasswordAvailableFromWsQuery__
 *
 * To run a query within a React component, call `useQueryPasswordAvailableFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryPasswordAvailableFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryPasswordAvailableFromWsQuery({
 *   variables: {
 *      password: // value for 'password'
 *   },
 * });
 */
export function useQueryPasswordAvailableFromWsQuery(
  baseOptions: Apollo.QueryHookOptions<QueryPasswordAvailableFromWsQuery, QueryPasswordAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryPasswordAvailableFromWsQuery, QueryPasswordAvailableFromWsQueryVariables>(
    QueryPasswordAvailableFromWsDocument,
    options
  )
}
export function useQueryPasswordAvailableFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryPasswordAvailableFromWsQuery, QueryPasswordAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryPasswordAvailableFromWsQuery, QueryPasswordAvailableFromWsQueryVariables>(
    QueryPasswordAvailableFromWsDocument,
    options
  )
}
export type QueryPasswordAvailableFromWsQueryHookResult = ReturnType<typeof useQueryPasswordAvailableFromWsQuery>
export type QueryPasswordAvailableFromWsLazyQueryHookResult = ReturnType<typeof useQueryPasswordAvailableFromWsLazyQuery>
export type QueryPasswordAvailableFromWsQueryResult = Apollo.QueryResult<
  QueryPasswordAvailableFromWsQuery,
  QueryPasswordAvailableFromWsQueryVariables
>
export const QueryWebidAvailableFromWsDocument = gql`
  query QueryWebidAvailableFromWS($webid: String!) {
    webidAvailable(webid: $webid) {
      success
      message
    }
  }
`

/**
 * __useQueryWebidAvailableFromWsQuery__
 *
 * To run a query within a React component, call `useQueryWebidAvailableFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryWebidAvailableFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryWebidAvailableFromWsQuery({
 *   variables: {
 *      webid: // value for 'webid'
 *   },
 * });
 */
export function useQueryWebidAvailableFromWsQuery(
  baseOptions: Apollo.QueryHookOptions<QueryWebidAvailableFromWsQuery, QueryWebidAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryWebidAvailableFromWsQuery, QueryWebidAvailableFromWsQueryVariables>(
    QueryWebidAvailableFromWsDocument,
    options
  )
}
export function useQueryWebidAvailableFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryWebidAvailableFromWsQuery, QueryWebidAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryWebidAvailableFromWsQuery, QueryWebidAvailableFromWsQueryVariables>(
    QueryWebidAvailableFromWsDocument,
    options
  )
}
export type QueryWebidAvailableFromWsQueryHookResult = ReturnType<typeof useQueryWebidAvailableFromWsQuery>
export type QueryWebidAvailableFromWsLazyQueryHookResult = ReturnType<typeof useQueryWebidAvailableFromWsLazyQuery>
export type QueryWebidAvailableFromWsQueryResult = Apollo.QueryResult<
  QueryWebidAvailableFromWsQuery,
  QueryWebidAvailableFromWsQueryVariables
>
export const GetAvailableLocalesFromWsDocument = gql`
  query GetAvailableLocalesFromWS {
    metadata {
      id
      availableLocales {
        label
        value
      }
    }
  }
`

/**
 * __useGetAvailableLocalesFromWsQuery__
 *
 * To run a query within a React component, call `useGetAvailableLocalesFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAvailableLocalesFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAvailableLocalesFromWsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAvailableLocalesFromWsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetAvailableLocalesFromWsQuery, GetAvailableLocalesFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAvailableLocalesFromWsQuery, GetAvailableLocalesFromWsQueryVariables>(
    GetAvailableLocalesFromWsDocument,
    options
  )
}
export function useGetAvailableLocalesFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetAvailableLocalesFromWsQuery, GetAvailableLocalesFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetAvailableLocalesFromWsQuery, GetAvailableLocalesFromWsQueryVariables>(
    GetAvailableLocalesFromWsDocument,
    options
  )
}
export type GetAvailableLocalesFromWsQueryHookResult = ReturnType<typeof useGetAvailableLocalesFromWsQuery>
export type GetAvailableLocalesFromWsLazyQueryHookResult = ReturnType<typeof useGetAvailableLocalesFromWsLazyQuery>
export type GetAvailableLocalesFromWsQueryResult = Apollo.QueryResult<
  GetAvailableLocalesFromWsQuery,
  GetAvailableLocalesFromWsQueryVariables
>
export const CreateDirectUploadDocument = gql`
  mutation createDirectUpload($input: CreateDirectUploadInput!) {
    createDirectUpload(input: $input) {
      directUpload {
        uploadUrl
        headers
        blobKey
        viewUrl
        signedId
      }
    }
  }
`
export type CreateDirectUploadMutationFn = Apollo.MutationFunction<CreateDirectUploadMutation, CreateDirectUploadMutationVariables>

/**
 * __useCreateDirectUploadMutation__
 *
 * To run a mutation, you first call `useCreateDirectUploadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDirectUploadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDirectUploadMutation, { data, loading, error }] = useCreateDirectUploadMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateDirectUploadMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateDirectUploadMutation, CreateDirectUploadMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateDirectUploadMutation, CreateDirectUploadMutationVariables>(CreateDirectUploadDocument, options)
}
export type CreateDirectUploadMutationHookResult = ReturnType<typeof useCreateDirectUploadMutation>
export type CreateDirectUploadMutationResult = Apollo.MutationResult<CreateDirectUploadMutation>
export type CreateDirectUploadMutationOptions = Apollo.BaseMutationOptions<CreateDirectUploadMutation, CreateDirectUploadMutationVariables>
export const GetPodsDocument = gql`
  query GetPods {
    pods {
      id
      webid
      name
      avatarData {
        url
        signedId
      }
      bio
    }
  }
`

/**
 * __useGetPodsQuery__
 *
 * To run a query within a React component, call `useGetPodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPodsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPodsQuery(baseOptions?: Apollo.QueryHookOptions<GetPodsQuery, GetPodsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPodsQuery, GetPodsQueryVariables>(GetPodsDocument, options)
}
export function useGetPodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPodsQuery, GetPodsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPodsQuery, GetPodsQueryVariables>(GetPodsDocument, options)
}
export type GetPodsQueryHookResult = ReturnType<typeof useGetPodsQuery>
export type GetPodsLazyQueryHookResult = ReturnType<typeof useGetPodsLazyQuery>
export type GetPodsQueryResult = Apollo.QueryResult<GetPodsQuery, GetPodsQueryVariables>
export const QueryUnsplashImageDocument = gql`
  query QueryUnsplashImage($query: String, $page: Int, $perPage: Int) {
    unsplashImage(query: $query, page: $page, perPage: $perPage) {
      id
      width
      height
      fullUrl
      smallUrl
      username
    }
  }
`

/**
 * __useQueryUnsplashImageQuery__
 *
 * To run a query within a React component, call `useQueryUnsplashImageQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryUnsplashImageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryUnsplashImageQuery({
 *   variables: {
 *      query: // value for 'query'
 *      page: // value for 'page'
 *      perPage: // value for 'perPage'
 *   },
 * });
 */
export function useQueryUnsplashImageQuery(
  baseOptions?: Apollo.QueryHookOptions<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>(QueryUnsplashImageDocument, options)
}
export function useQueryUnsplashImageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>(QueryUnsplashImageDocument, options)
}
export type QueryUnsplashImageQueryHookResult = ReturnType<typeof useQueryUnsplashImageQuery>
export type QueryUnsplashImageLazyQueryHookResult = ReturnType<typeof useQueryUnsplashImageLazyQuery>
export type QueryUnsplashImageQueryResult = Apollo.QueryResult<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>
export const CreateOrUpdatePodDocument = gql`
  mutation createOrUpdatePod($input: CreateOrUpdatePodInput!) {
    createOrUpdatePod(input: $input) {
      errors
      pod {
        webid
        name
      }
    }
  }
`
export type CreateOrUpdatePodMutationFn = Apollo.MutationFunction<CreateOrUpdatePodMutation, CreateOrUpdatePodMutationVariables>

/**
 * __useCreateOrUpdatePodMutation__
 *
 * To run a mutation, you first call `useCreateOrUpdatePodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrUpdatePodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrUpdatePodMutation, { data, loading, error }] = useCreateOrUpdatePodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateOrUpdatePodMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateOrUpdatePodMutation, CreateOrUpdatePodMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateOrUpdatePodMutation, CreateOrUpdatePodMutationVariables>(CreateOrUpdatePodDocument, options)
}
export type CreateOrUpdatePodMutationHookResult = ReturnType<typeof useCreateOrUpdatePodMutation>
export type CreateOrUpdatePodMutationResult = Apollo.MutationResult<CreateOrUpdatePodMutation>
export type CreateOrUpdatePodMutationOptions = Apollo.BaseMutationOptions<CreateOrUpdatePodMutation, CreateOrUpdatePodMutationVariables>
export const GetPageBlocksDocument = gql`
  query GetPageBlocks($webid: String!) {
    pageBlocks(webid: $webid) {
      id
      sort
      nextSort
      firstChildSort
      rootId
      parentId
      type
      text
      content
      data
      meta {
        cover {
          ... on BlockImage {
            type
            source
            key
          }
          ... on BlockColor {
            type
            color
          }
        }
        icon {
          ... on BlockImage {
            type
            source
            key
          }
          ... on BlockEmoji {
            type
            name
            emoji
          }
        }
      }
    }
  }
`

/**
 * __useGetPageBlocksQuery__
 *
 * To run a query within a React component, call `useGetPageBlocksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPageBlocksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPageBlocksQuery({
 *   variables: {
 *      webid: // value for 'webid'
 *   },
 * });
 */
export function useGetPageBlocksQuery(baseOptions: Apollo.QueryHookOptions<GetPageBlocksQuery, GetPageBlocksQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPageBlocksQuery, GetPageBlocksQueryVariables>(GetPageBlocksDocument, options)
}
export function useGetPageBlocksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPageBlocksQuery, GetPageBlocksQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPageBlocksQuery, GetPageBlocksQueryVariables>(GetPageBlocksDocument, options)
}
export type GetPageBlocksQueryHookResult = ReturnType<typeof useGetPageBlocksQuery>
export type GetPageBlocksLazyQueryHookResult = ReturnType<typeof useGetPageBlocksLazyQuery>
export type GetPageBlocksQueryResult = Apollo.QueryResult<GetPageBlocksQuery, GetPageBlocksQueryVariables>
export const GetBlockSnapshotsDocument = gql`
  query GetBlockSnapshots($id: String!) {
    blockSnapshots(id: $id) {
      id
      snapshotVersion
      name
    }
  }
`

/**
 * __useGetBlockSnapshotsQuery__
 *
 * To run a query within a React component, call `useGetBlockSnapshotsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBlockSnapshotsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBlockSnapshotsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBlockSnapshotsQuery(baseOptions: Apollo.QueryHookOptions<GetBlockSnapshotsQuery, GetBlockSnapshotsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBlockSnapshotsQuery, GetBlockSnapshotsQueryVariables>(GetBlockSnapshotsDocument, options)
}
export function useGetBlockSnapshotsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetBlockSnapshotsQuery, GetBlockSnapshotsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBlockSnapshotsQuery, GetBlockSnapshotsQueryVariables>(GetBlockSnapshotsDocument, options)
}
export type GetBlockSnapshotsQueryHookResult = ReturnType<typeof useGetBlockSnapshotsQuery>
export type GetBlockSnapshotsLazyQueryHookResult = ReturnType<typeof useGetBlockSnapshotsLazyQuery>
export type GetBlockSnapshotsQueryResult = Apollo.QueryResult<GetBlockSnapshotsQuery, GetBlockSnapshotsQueryVariables>
export const GetBlockHistoriesDocument = gql`
  query GetBlockHistories($id: String!) {
    blockHistories(id: $id) {
      id
      historyVersion
    }
  }
`

/**
 * __useGetBlockHistoriesQuery__
 *
 * To run a query within a React component, call `useGetBlockHistoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBlockHistoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBlockHistoriesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBlockHistoriesQuery(baseOptions: Apollo.QueryHookOptions<GetBlockHistoriesQuery, GetBlockHistoriesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBlockHistoriesQuery, GetBlockHistoriesQueryVariables>(GetBlockHistoriesDocument, options)
}
export function useGetBlockHistoriesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetBlockHistoriesQuery, GetBlockHistoriesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBlockHistoriesQuery, GetBlockHistoriesQueryVariables>(GetBlockHistoriesDocument, options)
}
export type GetBlockHistoriesQueryHookResult = ReturnType<typeof useGetBlockHistoriesQuery>
export type GetBlockHistoriesLazyQueryHookResult = ReturnType<typeof useGetBlockHistoriesLazyQuery>
export type GetBlockHistoriesQueryResult = Apollo.QueryResult<GetBlockHistoriesQuery, GetBlockHistoriesQueryVariables>
export const BlockDeleteDocument = gql`
  mutation blockDelete($input: BlockDeleteInput!) {
    blockDelete(input: $input) {
      errors
    }
  }
`
export type BlockDeleteMutationFn = Apollo.MutationFunction<BlockDeleteMutation, BlockDeleteMutationVariables>

/**
 * __useBlockDeleteMutation__
 *
 * To run a mutation, you first call `useBlockDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockDeleteMutation, { data, loading, error }] = useBlockDeleteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockDeleteMutation(baseOptions?: Apollo.MutationHookOptions<BlockDeleteMutation, BlockDeleteMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockDeleteMutation, BlockDeleteMutationVariables>(BlockDeleteDocument, options)
}
export type BlockDeleteMutationHookResult = ReturnType<typeof useBlockDeleteMutation>
export type BlockDeleteMutationResult = Apollo.MutationResult<BlockDeleteMutation>
export type BlockDeleteMutationOptions = Apollo.BaseMutationOptions<BlockDeleteMutation, BlockDeleteMutationVariables>
export const BlockCreateSubBlockDocument = gql`
  mutation blockCreateSubBlock($input: BlockCreateSubBlockInput!) {
    blockCreateSubBlock(input: $input) {
      errors
    }
  }
`
export type BlockCreateSubBlockMutationFn = Apollo.MutationFunction<BlockCreateSubBlockMutation, BlockCreateSubBlockMutationVariables>

/**
 * __useBlockCreateSubBlockMutation__
 *
 * To run a mutation, you first call `useBlockCreateSubBlockMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockCreateSubBlockMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockCreateSubBlockMutation, { data, loading, error }] = useBlockCreateSubBlockMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockCreateSubBlockMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockCreateSubBlockMutation, BlockCreateSubBlockMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockCreateSubBlockMutation, BlockCreateSubBlockMutationVariables>(BlockCreateSubBlockDocument, options)
}
export type BlockCreateSubBlockMutationHookResult = ReturnType<typeof useBlockCreateSubBlockMutation>
export type BlockCreateSubBlockMutationResult = Apollo.MutationResult<BlockCreateSubBlockMutation>
export type BlockCreateSubBlockMutationOptions = Apollo.BaseMutationOptions<
  BlockCreateSubBlockMutation,
  BlockCreateSubBlockMutationVariables
>
export const BlockCreateShareLinkDocument = gql`
  mutation blockCreateShareLink($input: BlockCreateShareLinkInput!) {
    blockCreateShareLink(input: $input) {
      errors
      shareLink {
        key
      }
    }
  }
`
export type BlockCreateShareLinkMutationFn = Apollo.MutationFunction<BlockCreateShareLinkMutation, BlockCreateShareLinkMutationVariables>

/**
 * __useBlockCreateShareLinkMutation__
 *
 * To run a mutation, you first call `useBlockCreateShareLinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockCreateShareLinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockCreateShareLinkMutation, { data, loading, error }] = useBlockCreateShareLinkMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockCreateShareLinkMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockCreateShareLinkMutation, BlockCreateShareLinkMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockCreateShareLinkMutation, BlockCreateShareLinkMutationVariables>(BlockCreateShareLinkDocument, options)
}
export type BlockCreateShareLinkMutationHookResult = ReturnType<typeof useBlockCreateShareLinkMutation>
export type BlockCreateShareLinkMutationResult = Apollo.MutationResult<BlockCreateShareLinkMutation>
export type BlockCreateShareLinkMutationOptions = Apollo.BaseMutationOptions<
  BlockCreateShareLinkMutation,
  BlockCreateShareLinkMutationVariables
>
export const BlockMoveDocument = gql`
  mutation blockMove($input: BlockMoveInput!) {
    blockMove(input: $input) {
      errors
    }
  }
`
export type BlockMoveMutationFn = Apollo.MutationFunction<BlockMoveMutation, BlockMoveMutationVariables>

/**
 * __useBlockMoveMutation__
 *
 * To run a mutation, you first call `useBlockMoveMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockMoveMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockMoveMutation, { data, loading, error }] = useBlockMoveMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockMoveMutation(baseOptions?: Apollo.MutationHookOptions<BlockMoveMutation, BlockMoveMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockMoveMutation, BlockMoveMutationVariables>(BlockMoveDocument, options)
}
export type BlockMoveMutationHookResult = ReturnType<typeof useBlockMoveMutation>
export type BlockMoveMutationResult = Apollo.MutationResult<BlockMoveMutation>
export type BlockMoveMutationOptions = Apollo.BaseMutationOptions<BlockMoveMutation, BlockMoveMutationVariables>
export const BlockCreateSnapshotDocument = gql`
  mutation blockCreateSnapshot($input: BlockCreateSnapshotInput!) {
    blockCreateSnapshot(input: $input) {
      errors
    }
  }
`
export type BlockCreateSnapshotMutationFn = Apollo.MutationFunction<BlockCreateSnapshotMutation, BlockCreateSnapshotMutationVariables>

/**
 * __useBlockCreateSnapshotMutation__
 *
 * To run a mutation, you first call `useBlockCreateSnapshotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockCreateSnapshotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockCreateSnapshotMutation, { data, loading, error }] = useBlockCreateSnapshotMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockCreateSnapshotMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockCreateSnapshotMutation, BlockCreateSnapshotMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockCreateSnapshotMutation, BlockCreateSnapshotMutationVariables>(BlockCreateSnapshotDocument, options)
}
export type BlockCreateSnapshotMutationHookResult = ReturnType<typeof useBlockCreateSnapshotMutation>
export type BlockCreateSnapshotMutationResult = Apollo.MutationResult<BlockCreateSnapshotMutation>
export type BlockCreateSnapshotMutationOptions = Apollo.BaseMutationOptions<
  BlockCreateSnapshotMutation,
  BlockCreateSnapshotMutationVariables
>
export const BlockSyncBatchDocument = gql`
  mutation blockSyncBatch($input: BlockSyncBatchInput!) {
    blockSyncBatch(input: $input) {
      errors
    }
  }
`
export type BlockSyncBatchMutationFn = Apollo.MutationFunction<BlockSyncBatchMutation, BlockSyncBatchMutationVariables>

/**
 * __useBlockSyncBatchMutation__
 *
 * To run a mutation, you first call `useBlockSyncBatchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockSyncBatchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockSyncBatchMutation, { data, loading, error }] = useBlockSyncBatchMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockSyncBatchMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockSyncBatchMutation, BlockSyncBatchMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockSyncBatchMutation, BlockSyncBatchMutationVariables>(BlockSyncBatchDocument, options)
}
export type BlockSyncBatchMutationHookResult = ReturnType<typeof useBlockSyncBatchMutation>
export type BlockSyncBatchMutationResult = Apollo.MutationResult<BlockSyncBatchMutation>
export type BlockSyncBatchMutationOptions = Apollo.BaseMutationOptions<BlockSyncBatchMutation, BlockSyncBatchMutationVariables>
export const NewPatchDocument = gql`
  subscription newPatch($docId: UUID!) {
    newPatch(docId: $docId) {
      state
      seq
      patches {
        id
        path
        patchType
        payload
        operatorId
      }
    }
  }
`

/**
 * __useNewPatchSubscription__
 *
 * To run a query within a React component, call `useNewPatchSubscription` and pass it any options that fit your needs.
 * When your component renders, `useNewPatchSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNewPatchSubscription({
 *   variables: {
 *      docId: // value for 'docId'
 *   },
 * });
 */
export function useNewPatchSubscription(baseOptions: Apollo.SubscriptionHookOptions<NewPatchSubscription, NewPatchSubscriptionVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<NewPatchSubscription, NewPatchSubscriptionVariables>(NewPatchDocument, options)
}
export type NewPatchSubscriptionHookResult = ReturnType<typeof useNewPatchSubscription>
export type NewPatchSubscriptionResult = Apollo.SubscriptionResult<NewPatchSubscription>
export const GetChildrenBlocksDocument = gql`
  query GetChildrenBlocks($rootId: String!, $snapshotVersion: Int!) {
    childrenBlocks(rootId: $rootId, snapshotVersion: $snapshotVersion) {
      id
      sort
      parentId
      rootId
      blobs {
        blobKey
        url
      }
      type
      text
      content
      data
      meta {
        title
        level
        image {
          type
          source
          key
          height
          width
          ratio
        }
        attachment {
          type
          source
          key
          height
          width
        }
        cover {
          ... on BlockImage {
            type
            source
            key
            height
            width
          }
          ... on BlockColor {
            type
            color
          }
        }
        icon {
          ... on BlockImage {
            type
            source
            key
            height
            width
          }
          ... on BlockEmoji {
            type
            name
            emoji
          }
        }
      }
    }
  }
`

/**
 * __useGetChildrenBlocksQuery__
 *
 * To run a query within a React component, call `useGetChildrenBlocksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChildrenBlocksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChildrenBlocksQuery({
 *   variables: {
 *      rootId: // value for 'rootId'
 *      snapshotVersion: // value for 'snapshotVersion'
 *   },
 * });
 */
export function useGetChildrenBlocksQuery(baseOptions: Apollo.QueryHookOptions<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>(GetChildrenBlocksDocument, options)
}
export function useGetChildrenBlocksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>(GetChildrenBlocksDocument, options)
}
export type GetChildrenBlocksQueryHookResult = ReturnType<typeof useGetChildrenBlocksQuery>
export type GetChildrenBlocksLazyQueryHookResult = ReturnType<typeof useGetChildrenBlocksLazyQuery>
export type GetChildrenBlocksQueryResult = Apollo.QueryResult<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>
