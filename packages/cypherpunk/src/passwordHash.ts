import { Buffer } from 'buffer'
import { string2Buffer } from './utils'
import { crypto_pwhash_str, crypto_pwhash_str_verify, crypto_pwhash_STRBYTES } from 'sodium-native'

/**
 * NOTES:
 * Argon2id should use one of the following configuration settings as a base
 * minimum which includes the minimum memory size (m), the minimum number of
 *  iterations (ops) and the degree of parallelism (p).
 * m=37 MiB, ops=1, p=1
 * m=15 MiB, ops=2, p=1
 * Both of these configuration settings are equivalent in the defense they provide.
 * The only difference is a trade off between CPU and RAM usage
 * @see {@link https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#argon2id}
 */
const defaultOps = 2
const defaultMem = 15_728_640 // 15 MiB

/**
 * Generate a password hash and salt using Argon2id
 * @param password - input string
 * @param opslimit - number of iterations
 * @param memlimit - number of bytes of memory
 * @returns password hash
 */
export function passwordHash(password: string, opslimit = defaultOps, memlimit = defaultMem): string {
  const hashBuffer = Buffer.alloc(crypto_pwhash_STRBYTES)
  const passwordBuffer = string2Buffer(password)
  crypto_pwhash_str(hashBuffer, passwordBuffer, opslimit, memlimit)

  // The `crypto_pwhash_str()` function puts an **ASCII** encoded string into out
  return hashBuffer.toString('ascii')
}

/**
 * Verifies a password hash generated by `passwordHash()`
 * @param hash - password hash
 * @param password - input string
 * @returns `true` if the password matches the hash
 */
export function verifyPasswordHash(hash: string, password: string): boolean {
  // `hashStr` is a **ASCII** encoded string
  let str = string2Buffer(hash, 'ascii')

  // fill the buffer with zeros if the length is less than `crypto_pwhash_STRBYTES`
  if (str.length < crypto_pwhash_STRBYTES) {
    str = Buffer.concat([str, Buffer.alloc(crypto_pwhash_STRBYTES - str.length)])
  }

  return crypto_pwhash_str_verify(str, string2Buffer(password))
}
