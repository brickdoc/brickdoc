import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** AutoIncrement Primary Key */
  AutoIncrementID: string
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: any
  /** Email Address */
  Email: string
  /** A valid http/https url or image uri */
  HttpUrl: string
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any
  /** Represents untyped JSON */
  JSON: any
  /** UUID V4 */
  UUID: string
}

/** Available authentication authentication. */
export enum AuthMethod {
  /** Email and Password Authentication */
  EmailPassword = 'email_password',
  /**  Federated Authentication */
  Github = 'github',
  /**  Federated Authentication */
  GoogleOauth2 = 'google_oauth2'
}

export type AuthorizationResult = {
  __typename?: 'AuthorizationResult'
  /** Human-readable error message */
  message?: Maybe<Scalars['String']>
  /** Reasons of check failure */
  reasons?: Maybe<FailureReasons>
  /** Result of applying a policy rule */
  value: Scalars['Boolean']
}

export type Avatar = {
  __typename?: 'Avatar'
  /** download url */
  downloadUrl: Scalars['String']
  /** signed id */
  signedId: Scalars['String']
  /** url */
  url: Scalars['String']
}

/** ActiveStorage blobs */
export type Blob = {
  __typename?: 'Blob'
  /** Blob key */
  blobKey: Scalars['String']
  /** Blob url */
  downloadUrl: Scalars['String']
  /** Blob url */
  url: Scalars['String']
}

/** Brickdoc Docs::Block */
export type Block = {
  __typename?: 'Block'
  /** blobs */
  blobs?: Maybe<Array<Blob>>
  /** collaborators */
  collaborators: Array<Scalars['BigInt']>
  /** content */
  content: Array<Scalars['JSON']>
  data: Scalars['JSON']
  /** deleted_at */
  deletedAt?: Maybe<Scalars['ISO8601DateTime']>
  /** block first child sort */
  firstChildSort: Scalars['BigInt']
  /** object unique id */
  id: Scalars['UUID']
  meta: BlockMeta
  /** block next sort */
  nextSort: Scalars['BigInt']
  /** parent uuid */
  parentId?: Maybe<Scalars['UUID']>
  /** path */
  pathArray: Array<BlockPath>
  permissions: BlockBaseObjectPermissions
  /** root uuid */
  rootId: Scalars['UUID']
  /** block sort */
  sort: Scalars['BigInt']
  /** text */
  text: Scalars['String']
  /** block type */
  type: Scalars['String']
}

export type BlockAlias = {
  __typename?: 'BlockAlias'
  key: Scalars['String']
  payload: Scalars['JSON']
}

export type BlockAttachment = {
  __typename?: 'BlockAttachment'
  /** display name */
  displayName?: Maybe<Scalars['String']>
  /** height */
  height?: Maybe<Scalars['Int']>
  /** url or blob key */
  key?: Maybe<Scalars['String']>
  /** mode */
  mode?: Maybe<Scalars['String']>
  /** name */
  name?: Maybe<Scalars['String']>
  /** size */
  size?: Maybe<Scalars['Int']>
  /** source */
  source?: Maybe<FileSource>
  /** type */
  type: BlockType
  /** view url */
  viewUrl?: Maybe<Scalars['String']>
  /** width */
  width?: Maybe<Scalars['Int']>
}

export type BlockColor = {
  __typename?: 'BlockColor'
  /** string */
  color: Scalars['String']
  /** type */
  type?: Maybe<BlockType>
}

/** InputObject type of Class */
export type BlockCommitInput = {
  /** block id */
  blockId: Scalars['UUID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** document id */
  documentId: Scalars['UUID']
  /** operator id */
  operatorId: Scalars['String']
  /** previous state id */
  prevStateId?: InputMaybe<Scalars['UUID']>
  /** full or update state */
  state: Scalars['String']
  /** state id */
  stateId: Scalars['UUID']
  /** state type */
  stateType: Statetype
  /** states count */
  statesCount: Scalars['Int']
}

/** Autogenerated return type of BlockCommit */
export type BlockCommitPayload = {
  __typename?: 'BlockCommitPayload'
  block?: Maybe<BlockNew>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Differ Block States with current state */
  diffStates?: Maybe<Array<BlockState>>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  requireFull?: Maybe<Scalars['Boolean']>
}

export type BlockCover = BlockColor | BlockImage

/** InputObject type of Class */
export type BlockCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** parent id */
  parentId?: InputMaybe<Scalars['UUID']>
  /** title */
  title: Scalars['String']
}

/** Autogenerated return type of BlockCreate */
export type BlockCreatePayload = {
  __typename?: 'BlockCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  id: Scalars['UUID']
}

/** InputObject type of Class */
export type BlockCreateShareLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** block id */
  id: Scalars['UUID']
  /** share link target */
  target: Array<ShareLinkInput>
}

/** Autogenerated return type of BlockCreateShareLink */
export type BlockCreateShareLinkPayload = {
  __typename?: 'BlockCreateShareLinkPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type BlockDuplicateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** block unique id */
  id: Scalars['UUID']
}

/** Autogenerated return type of BlockDuplicate */
export type BlockDuplicatePayload = {
  __typename?: 'BlockDuplicatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  formulaIds: Array<Scalars['UUID']>
  id: Scalars['UUID']
}

export type BlockEmbedMeta = {
  __typename?: 'BlockEmbedMeta'
  /** display name */
  displayName?: Maybe<Scalars['String']>
  /** embedType */
  embedType?: Maybe<EmbedType>
  /** height */
  height?: Maybe<Scalars['Int']>
  /** url or blob key */
  key?: Maybe<Scalars['String']>
  /** mode */
  mode?: Maybe<Scalars['String']>
  /** name */
  name?: Maybe<Scalars['String']>
  /** size */
  size?: Maybe<Scalars['Int']>
  /** source */
  source?: Maybe<FileSource>
  /** type */
  type?: Maybe<Scalars['String']>
  /** view url */
  viewUrl?: Maybe<Scalars['String']>
  /** width */
  width?: Maybe<Scalars['Int']>
}

export type BlockEmoji = {
  __typename?: 'BlockEmoji'
  /** emoji */
  emoji: Scalars['String']
  /** name */
  name: Scalars['String']
  /** type */
  type?: Maybe<BlockType>
}

/** InputObject type of Class */
export type BlockHardDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** block unique id */
  ids: Array<Scalars['UUID']>
}

/** Autogenerated return type of BlockHardDelete */
export type BlockHardDeletePayload = {
  __typename?: 'BlockHardDeletePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export type BlockIcon = BlockEmoji | BlockImage

export type BlockImage = {
  __typename?: 'BlockImage'
  /** align */
  align?: Maybe<Scalars['String']>
  /** display name */
  displayName?: Maybe<Scalars['String']>
  /** height */
  height?: Maybe<Scalars['Int']>
  /** key */
  key?: Maybe<Scalars['String']>
  /** mode */
  mode?: Maybe<Scalars['String']>
  /** name */
  name?: Maybe<Scalars['String']>
  /** aspect ratio */
  ratio?: Maybe<Scalars['Float']>
  /** size */
  size?: Maybe<Scalars['Int']>
  /** type */
  source?: Maybe<FileSource>
  /** type */
  type?: Maybe<BlockType>
  /** view url */
  viewUrl?: Maybe<Scalars['String']>
  /** width */
  width?: Maybe<Scalars['Int']>
}

export type BlockInfo = {
  __typename?: 'BlockInfo'
  /** pod */
  collaborators: Array<Pod>
  /** alias */
  enabledAlias?: Maybe<BlockAlias>
  /** icon */
  icon?: Maybe<BlockIcon>
  /** id */
  id: Scalars['UUID']
  /** is deleted */
  isDeleted: Scalars['Boolean']
  /** is master */
  isMaster: Scalars['Boolean']
  /** path */
  pathArray: Array<BlockPath>
  /** permission */
  permission?: Maybe<ShareLink>
  /** pin */
  pin: Scalars['Boolean']
  /** title */
  title: Scalars['String']
}

/** InputObject type of Class */
export type BlockInput = {
  /** attachments */
  attachments?: InputMaybe<Array<Scalars['String']>>
  /** content */
  content: Array<Scalars['JSON']>
  /** data */
  data?: InputMaybe<Scalars['JSON']>
  /** block unique id */
  id: Scalars['UUID']
  /** meta */
  meta?: InputMaybe<Scalars['JSON']>
  /** parent uuid */
  parentId?: InputMaybe<Scalars['UUID']>
  /** block sort */
  sort?: InputMaybe<Scalars['BigInt']>
  /** text */
  text: Scalars['String']
  /** block type */
  type: Scalars['String']
}

export type BlockLink = {
  __typename?: 'BlockLink'
  /** cover */
  cover?: Maybe<Scalars['String']>
  /** description */
  description?: Maybe<Scalars['String']>
  /** display name */
  displayName?: Maybe<Scalars['String']>
  /** height */
  height?: Maybe<Scalars['Int']>
  /** icon */
  icon?: Maybe<Scalars['String']>
  /** key */
  key?: Maybe<Scalars['String']>
  /** mode */
  mode?: Maybe<Scalars['String']>
  /** name */
  name?: Maybe<Scalars['String']>
  /** size */
  size?: Maybe<Scalars['Int']>
  /** source */
  source?: Maybe<FileSource>
  /** title */
  title?: Maybe<Scalars['String']>
  /** type */
  type: Scalars['String']
  /** view url */
  viewUrl?: Maybe<Scalars['String']>
  /** width */
  width?: Maybe<Scalars['Int']>
}

export type BlockMeta = {
  __typename?: 'BlockMeta'
  /** attachment */
  attachment?: Maybe<BlockAttachment>
  /** code auto wrap */
  autoWrap?: Maybe<Scalars['Boolean']>
  /** cover */
  cover?: Maybe<BlockCover>
  /** embedMeta */
  embedMeta?: Maybe<BlockEmbedMeta>
  /** icon */
  icon?: Maybe<BlockIcon>
  /** image */
  image?: Maybe<BlockImage>
  /** Prosemirror builtin language */
  language?: Maybe<Scalars['String']>
  /** Prosemirror builtin level */
  level?: Maybe<Scalars['Int']>
  /** link */
  link?: Maybe<BlockLink>
  /** page */
  page?: Maybe<BlockPage>
  /** people */
  people?: Maybe<BlockPeople>
  /** Prosemirror builtin start */
  start?: Maybe<Scalars['String']>
  /** title */
  title?: Maybe<Scalars['String']>
}

/** InputObject type of Class */
export type BlockMoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** block unique id */
  id: Scalars['UUID']
  /** block sort */
  sort: Scalars['BigInt']
  /** target parent id */
  targetParentId?: InputMaybe<Scalars['UUID']>
}

/** Autogenerated return type of BlockMove */
export type BlockMovePayload = {
  __typename?: 'BlockMovePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Brickdoc Docs::Block New Scheme */
export type BlockNew = {
  __typename?: 'BlockNew'
  /** Block Type */
  blockType?: Maybe<Scalars['String']>
  /** object unique id */
  id: Scalars['UUID']
  /** Latest State Id */
  stateId?: Maybe<Scalars['String']>
  /** Block States */
  states?: Maybe<Array<BlockState>>
  statesCount?: Maybe<Scalars['Int']>
}

export type BlockPage = {
  __typename?: 'BlockPage'
  /** display name */
  displayName?: Maybe<Scalars['String']>
  /** height */
  height?: Maybe<Scalars['Int']>
  /** icon */
  icon?: Maybe<Scalars['String']>
  /** key */
  key: Scalars['String']
  /** link */
  link: Scalars['String']
  /** mode */
  mode?: Maybe<Scalars['String']>
  /** name */
  name?: Maybe<Scalars['String']>
  /** size */
  size?: Maybe<Scalars['Int']>
  /** source */
  source?: Maybe<FileSource>
  /** title */
  title?: Maybe<Scalars['String']>
  /** type */
  type?: Maybe<BlockType>
  /** view url */
  viewUrl?: Maybe<Scalars['String']>
  /** width */
  width?: Maybe<Scalars['Int']>
}

export type BlockPath = {
  __typename?: 'BlockPath'
  /** icon */
  icon?: Maybe<BlockIcon>
  /** icon */
  id: Scalars['UUID']
  /** cover */
  text: Scalars['String']
}

export type BlockPeople = {
  __typename?: 'BlockPeople'
  /** avatar */
  avatarUrl?: Maybe<Scalars['String']>
  /** display name */
  displayName?: Maybe<Scalars['String']>
  /** key */
  domain: Scalars['String']
  /** height */
  height?: Maybe<Scalars['Int']>
  /** url or blob key */
  key?: Maybe<Scalars['String']>
  /** mode */
  mode?: Maybe<Scalars['String']>
  /** name */
  name?: Maybe<Scalars['String']>
  /** size */
  size?: Maybe<Scalars['Int']>
  /** source */
  source?: Maybe<FileSource>
  /** type */
  type?: Maybe<BlockType>
  /** view url */
  viewUrl?: Maybe<Scalars['String']>
  /** width */
  width?: Maybe<Scalars['Int']>
}

/** InputObject type of Class */
export type BlockPinOrUnpinInput = {
  /** block id */
  blockId: Scalars['UUID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** pin */
  pin: Scalars['Boolean']
}

/** Autogenerated return type of BlockPinOrUnpin */
export type BlockPinOrUnpinPayload = {
  __typename?: 'BlockPinOrUnpinPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type BlockRenameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** block id */
  id: Scalars['UUID']
  /** New title */
  title: Scalars['String']
}

/** Autogenerated return type of BlockRename */
export type BlockRenamePayload = {
  __typename?: 'BlockRenamePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type BlockRestoreInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** block unique id */
  ids: Array<Scalars['UUID']>
}

/** Autogenerated return type of BlockRestore */
export type BlockRestorePayload = {
  __typename?: 'BlockRestorePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export type BlockSnapshot = {
  __typename?: 'BlockSnapshot'
  /** created at */
  createdAt: Scalars['ISO8601DateTime']
  /** object unique id */
  id: Scalars['AutoIncrementID']
  /** Snapshot name */
  name: Scalars['String']
  /** relative time */
  relativeTime: Scalars['String']
  /** Snapshot version */
  snapshotVersion: Scalars['Int']
}

/** InputObject type of Class */
export type BlockSoftDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** hard delete */
  hardDelete: Scalars['Boolean']
  /** block unique id */
  id: Scalars['UUID']
}

/** Autogenerated return type of BlockSoftDelete */
export type BlockSoftDeletePayload = {
  __typename?: 'BlockSoftDeletePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Brickdoc Docs::BlockState */
export type BlockState = {
  __typename?: 'BlockState'
  blockId?: Maybe<Scalars['UUID']>
  /** Created at */
  createdAt: Scalars['ISO8601DateTime']
  /** object unique id */
  id: Scalars['UUID']
  prevStateId?: Maybe<Scalars['UUID']>
  state?: Maybe<Scalars['String']>
  /** State Type */
  stateType?: Maybe<Statetype>
}

/** InputObject type of Class */
export type BlockSyncBatchInput = {
  blocks: Array<BlockInput>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** deleted ids */
  deletedIds: Array<Scalars['UUID']>
  /** operator id */
  operatorId: Scalars['String']
  /** block root id */
  rootId: Scalars['UUID']
}

/** Autogenerated return type of BlockSyncBatch */
export type BlockSyncBatchPayload = {
  __typename?: 'BlockSyncBatchPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export enum BlockType {
  /** ATTACHMENT */
  Attachment = 'ATTACHMENT',
  /** COLOR */
  Color = 'COLOR',
  /** EMOJI */
  Emoji = 'EMOJI',
  /** IMAGE */
  Image = 'IMAGE',
  /** PAGE */
  Page = 'PAGE',
  /** PEOPLE */
  People = 'PEOPLE'
}

/** Brickdoc Docs::Comment */
export type Comment = {
  __typename?: 'Comment'
  /** content */
  content: Scalars['JSON']
  /** created at */
  createdAt: Scalars['ISO8601DateTime']
  /** creator */
  creator: ThinUser
  id: Scalars['String']
  /** status */
  status: CommentStatus
  /** updated at */
  updatedAt: Scalars['ISO8601DateTime']
}

export enum CommentStatus {
  /** DELETED */
  Deleted = 'deleted',
  /** NORMAL */
  Normal = 'normal'
}

/** Brickdoc Global Configuration */
export type Config = {
  __typename?: 'Config'
  /** Enable email and password authentication */
  accountsEmailPasswordAuth: Scalars['Boolean']
  /** Enabled federated identity providers */
  accountsFederatedProviders?: Maybe<Array<FederatedProvider>>
  /** Preferred Authentication authentication */
  accountsPreferredAuthMethod: AuthMethod
  /** User agreement link */
  userAgreementLink: Scalars['HttpUrl']
}

/** Brickdoc Docs::Conversation */
export type Conversation = {
  __typename?: 'Conversation'
  /** blockIds */
  blockIds: Array<Scalars['UUID']>
  comments: Array<Comment>
  /** created at */
  createdAt: Scalars['ISO8601DateTime']
  docId: Scalars['UUID']
  id: Scalars['String']
  /** latestReplyAt */
  latestReplyAt?: Maybe<Scalars['ISO8601DateTime']>
  /** markIds */
  markIds: Array<Scalars['UUID']>
  /** status */
  status: ConversationStatus
  /** updated at */
  updatedAt: Scalars['ISO8601DateTime']
}

/** InputObject type of Class */
export type ConversationCommentAppendInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  content: Scalars['JSON']
  /** Conversation id */
  conversationId: Scalars['String']
}

/** Autogenerated return type of ConversationCommentAppend */
export type ConversationCommentAppendPayload = {
  __typename?: 'ConversationCommentAppendPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  comment: Comment
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type ConversationCommentCreateInput = {
  blockIds?: InputMaybe<Array<Scalars['UUID']>>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  content: Scalars['JSON']
  /** comment doc id */
  docId: Scalars['UUID']
  markIds?: InputMaybe<Array<Scalars['UUID']>>
}

/** Autogenerated return type of ConversationCommentCreate */
export type ConversationCommentCreatePayload = {
  __typename?: 'ConversationCommentCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  conversation: Conversation
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export enum ConversationStatus {
  /** DELETED */
  Deleted = 'deleted',
  /** OPENED */
  Opened = 'opened',
  /** RESOLVED */
  Resolved = 'resolved'
}

/** InputObject type of Class */
export type CreateDirectUploadInput = {
  /** block id */
  blockId?: InputMaybe<Scalars['UUID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  input: DirectUploadInput
  type: Upload
}

/** Autogenerated return type of CreateDirectUpload */
export type CreateDirectUploadPayload = {
  __typename?: 'CreateDirectUploadPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  directUpload: DirectUpload
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type CreateOrUpdatePodInput = {
  /** Avatar signed id */
  avatarSignedId?: InputMaybe<Scalars['String']>
  /** bio */
  bio?: InputMaybe<Scalars['String']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** domain */
  domain: Scalars['String']
  /** invite enable */
  inviteEnable?: InputMaybe<Scalars['Boolean']>
  /** invite secret */
  inviteSecret?: InputMaybe<Scalars['String']>
  /** pod name */
  name?: InputMaybe<Scalars['String']>
  type: PodOperation
}

/** Autogenerated return type of CreateOrUpdatePod */
export type CreateOrUpdatePodPayload = {
  __typename?: 'CreateOrUpdatePodPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  pod?: Maybe<Pod>
}

/** Represents direct upload credentials */
export type DirectUpload = {
  __typename?: 'DirectUpload'
  /** Created blob record key */
  blobKey: Scalars['String']
  /** Download url */
  downloadUrl: Scalars['String']
  /** HTTP request headers (JSON-encoded) */
  headers: Scalars['JSON']
  /** Blob signed id */
  signedId: Scalars['String']
  /** Upload URL */
  uploadUrl: Scalars['String']
  /** View url */
  viewUrl: Scalars['String']
}

/** File information required to prepare a direct upload */
export type DirectUploadInput = {
  /** File size (bytes) */
  byteSize: Scalars['Int']
  /** MD5 file checksum as base64 */
  checksum: Scalars['String']
  /** File content type */
  contentType: Scalars['String']
  /** Original file name */
  filename: Scalars['String']
  /** metadata */
  metadata?: InputMaybe<Scalars['JSON']>
}

export type DocumentHistories = {
  __typename?: 'DocumentHistories'
  /** History States */
  histories?: Maybe<Array<DocumentHistory>>
  /** History Users */
  users?: Maybe<Array<ThinUser>>
}

export type DocumentHistory = {
  __typename?: 'DocumentHistory'
  /** Created at */
  createdAt: Scalars['ISO8601DateTime']
  /** object unique id */
  id: Scalars['UUID']
  /** Username */
  username: Scalars['String']
}

/** Autogenerated return type of Document */
export type DocumentPayload = {
  __typename?: 'DocumentPayload'
  blocks?: Maybe<Array<BlockNew>>
  histories?: Maybe<Array<DocumentHistory>>
  operatorId?: Maybe<Scalars['UUID']>
  states?: Maybe<Array<BlockState>>
}

export enum EmbedType {
  /** GALLERY */
  Gallery = 'GALLERY',
  /** LINK */
  Link = 'LINK',
  /** UPLOAD */
  Upload = 'UPLOAD'
}

export type FailureReasons = {
  __typename?: 'FailureReasons'
  /** JSON-encoded map of reasons */
  details: Scalars['String']
  /** Human-readable errors */
  fullMessages: Array<Scalars['String']>
}

/** Accounts Federated Identity Provide Configuration */
export type FederatedProvider = {
  __typename?: 'FederatedProvider'
  /** Provider Logo URI */
  logo: Scalars['HttpUrl']
  /** Provider Name */
  name: Scalars['String']
}

export enum FileSource {
  /** EXTERNAL */
  External = 'EXTERNAL',
  /** ORIGIN */
  Origin = 'ORIGIN'
}

export type Formula = {
  __typename?: 'Formula'
  /** block id */
  blockId: Scalars['UUID']
  /** dump value */
  cacheValue: Scalars['JSON']
  /** created at */
  createdAt: Scalars['Int']
  /** formula definition */
  definition: Scalars['String']
  /** object unique id */
  id: Scalars['UUID']
  /** meta */
  meta: Scalars['JSON']
  /** formula name */
  name: Scalars['String']
  /** type */
  type: Scalars['String']
  /** updated at */
  updatedAt: Scalars['ISO8601DateTime']
  /** version */
  version: Scalars['Int']
}

/** InputObject type of Class */
export type FormulaCommitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  commitFormulas: Array<FormulaModifyInput>
  deleteFormulas: Array<FormulaDeleteInput>
}

/** Autogenerated return type of FormulaCommit */
export type FormulaCommitPayload = {
  __typename?: 'FormulaCommitPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type FormulaDeleteInput = {
  /** block id */
  blockId: Scalars['UUID']
  /** id */
  id: Scalars['UUID']
}

/** InputObject type of Class */
export type FormulaModifyInput = {
  /** block id */
  blockId: Scalars['UUID']
  /** dump value */
  cacheValue: Scalars['JSON']
  /** definition */
  definition: Scalars['String']
  /** id */
  id: Scalars['UUID']
  /** meta */
  meta: Scalars['JSON']
  /** name */
  name: Scalars['String']
  /** type */
  type: Scalars['String']
  /** version */
  version: Scalars['Int']
}

/** InputObject type of Class */
export type JoinPodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** invite secret */
  inviteSecret?: InputMaybe<Scalars['String']>
}

/** Autogenerated return type of JoinPod */
export type JoinPodPayload = {
  __typename?: 'JoinPodPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export enum MemberRole {
  /** ADMIN */
  Admin = 'admin',
  /** MEMBER */
  Member = 'member'
}

export enum MemberState {
  /** DISABLED */
  Disabled = 'disabled',
  /** ENABLED */
  Enabled = 'enabled'
}

/** Represents information about the Brickdoc Server Instance. */
export type Metadata = {
  __typename?: 'Metadata'
  /** Current available locales. */
  availableLocales: Array<SelectOption>
  availableTimezones: Array<Scalars['String']>
  /** Brickdoc Global Config */
  config: Config
  /** object unique id */
  id: Scalars['AutoIncrementID']
}

export type Mutation = {
  __typename?: 'Mutation'
  blockCommit?: Maybe<BlockCommitPayload>
  blockCreate?: Maybe<BlockCreatePayload>
  blockCreateShareLink?: Maybe<BlockCreateShareLinkPayload>
  blockDuplicate?: Maybe<BlockDuplicatePayload>
  blockHardDelete?: Maybe<BlockHardDeletePayload>
  blockMove?: Maybe<BlockMovePayload>
  blockPinOrUnpin?: Maybe<BlockPinOrUnpinPayload>
  blockRename?: Maybe<BlockRenamePayload>
  blockRestore?: Maybe<BlockRestorePayload>
  blockSoftDelete?: Maybe<BlockSoftDeletePayload>
  blockSyncBatch?: Maybe<BlockSyncBatchPayload>
  conversationCommentAppend?: Maybe<ConversationCommentAppendPayload>
  conversationCommentCreate?: Maybe<ConversationCommentCreatePayload>
  createDirectUpload?: Maybe<CreateDirectUploadPayload>
  createOrUpdatePod?: Maybe<CreateOrUpdatePodPayload>
  formulaCommit?: Maybe<FormulaCommitPayload>
  joinPod?: Maybe<JoinPodPayload>
  podDestroy?: Maybe<PodDestroyPayload>
  podLeave?: Maybe<PodLeavePayload>
  updateDomain?: Maybe<UpdateDomainPayload>
  updateMember?: Maybe<UpdateMemberPayload>
  userAppearanceUpdate?: Maybe<UserAppearanceUpdatePayload>
  userConfirmationEmailResend?: Maybe<UserConfirmationEmailResendPayload>
  userCreate?: Maybe<UserCreatePayload>
  userDestroy?: Maybe<UserDestroyPayload>
  userEmailPasswordSignIn?: Maybe<UserEmailPasswordSignInPayload>
  userForgetPasswordMailSend?: Maybe<UserForgetPasswordMailSendPayload>
  userPasswordReset?: Maybe<UserPasswordResetPayload>
  userSignOut?: Maybe<UserSignOutPayload>
}

export type MutationBlockCommitArgs = {
  input: BlockCommitInput
}

export type MutationBlockCreateArgs = {
  input: BlockCreateInput
}

export type MutationBlockCreateShareLinkArgs = {
  input: BlockCreateShareLinkInput
}

export type MutationBlockDuplicateArgs = {
  input: BlockDuplicateInput
}

export type MutationBlockHardDeleteArgs = {
  input: BlockHardDeleteInput
}

export type MutationBlockMoveArgs = {
  input: BlockMoveInput
}

export type MutationBlockPinOrUnpinArgs = {
  input: BlockPinOrUnpinInput
}

export type MutationBlockRenameArgs = {
  input: BlockRenameInput
}

export type MutationBlockRestoreArgs = {
  input: BlockRestoreInput
}

export type MutationBlockSoftDeleteArgs = {
  input: BlockSoftDeleteInput
}

export type MutationBlockSyncBatchArgs = {
  input: BlockSyncBatchInput
}

export type MutationConversationCommentAppendArgs = {
  input: ConversationCommentAppendInput
}

export type MutationConversationCommentCreateArgs = {
  input: ConversationCommentCreateInput
}

export type MutationCreateDirectUploadArgs = {
  input: CreateDirectUploadInput
}

export type MutationCreateOrUpdatePodArgs = {
  input: CreateOrUpdatePodInput
}

export type MutationFormulaCommitArgs = {
  input: FormulaCommitInput
}

export type MutationJoinPodArgs = {
  input: JoinPodInput
}

export type MutationPodDestroyArgs = {
  input: PodDestroyInput
}

export type MutationPodLeaveArgs = {
  input: PodLeaveInput
}

export type MutationUpdateDomainArgs = {
  input: UpdateDomainInput
}

export type MutationUpdateMemberArgs = {
  input: UpdateMemberInput
}

export type MutationUserAppearanceUpdateArgs = {
  input: UserAppearanceUpdateInput
}

export type MutationUserConfirmationEmailResendArgs = {
  input: UserConfirmationEmailResendInput
}

export type MutationUserCreateArgs = {
  input: UserCreateInput
}

export type MutationUserDestroyArgs = {
  input: UserDestroyInput
}

export type MutationUserEmailPasswordSignInArgs = {
  input: UserEmailPasswordSignInInput
}

export type MutationUserForgetPasswordMailSendArgs = {
  input: UserForgetPasswordMailSendInput
}

export type MutationUserPasswordResetArgs = {
  input: UserPasswordResetInput
}

export type MutationUserSignOutArgs = {
  input: UserSignOutInput
}

/** Autogenerated return type of NewPatch */
export type NewPatchPayload = {
  __typename?: 'NewPatchPayload'
  patches: Array<PatchBaseObject>
  seq: Scalars['Int']
  state: Patchstate
}

/** session[:omniauth] */
export type OmniauthSession = {
  __typename?: 'OmniauthSession'
  /** Like a username, Unique within this instance of Brickdoc. */
  domain?: Maybe<Scalars['String']>
  hasSession: Scalars['Boolean']
  /** Human-readable name of the user */
  name?: Maybe<Scalars['String']>
  /** Provider Name */
  provider?: Maybe<Scalars['String']>
}

export type PatchBaseObject = {
  __typename?: 'PatchBaseObject'
  id: Scalars['UUID']
  operatorId: Scalars['String']
  patchType: Patchtype
  path: Array<Scalars['UUID']>
  payload: Scalars['JSON']
}

export enum Patchstate {
  /** ACTIVE */
  Active = 'ACTIVE',
  /** DELETED */
  Deleted = 'DELETED',
  /** SUBSCRIBED */
  Subscribed = 'SUBSCRIBED'
}

export enum Patchtype {
  /** ADD */
  Add = 'ADD',
  /** DELETE */
  Delete = 'DELETE',
  /** UPDATE */
  Update = 'UPDATE'
}

/** Brickdoc Docs::Pin */
export type Pin = {
  __typename?: 'Pin'
  /** root uuid */
  blockId: Scalars['UUID']
  meta: BlockMeta
  /** text */
  text: Scalars['String']
}

/** Brickdoc Pod. */
export type Pod = {
  __typename?: 'Pod'
  /** Pod Avatar */
  avatarData?: Maybe<Avatar>
  /** public profile bio */
  bio?: Maybe<Scalars['String']>
  /** Like a username, Unique within this instance of Brickdoc */
  domain: Scalars['String']
  /** owner email */
  email?: Maybe<Scalars['String']>
  /** object unique id */
  id: Scalars['AutoIncrementID']
  /** enable invite feature */
  inviteEnable: Scalars['Boolean']
  /** invite secret */
  inviteSecret?: Maybe<Scalars['String']>
  /** Pod Name */
  name?: Maybe<Scalars['String']>
  /** owner is current user */
  owned: Scalars['Boolean']
  /** personal */
  personal: Scalars['Boolean']
}

/** InputObject type of Class */
export type PodDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** domain */
  domain: Scalars['String']
}

/** Autogenerated return type of PodDestroy */
export type PodDestroyPayload = {
  __typename?: 'PodDestroyPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type PodLeaveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** Pod domain */
  domain: Scalars['String']
  /** User domain */
  userDomain: Scalars['String']
}

/** Autogenerated return type of PodLeave */
export type PodLeavePayload = {
  __typename?: 'PodLeavePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export type PodMember = {
  __typename?: 'PodMember'
  /** Pod Avatar */
  avatarData?: Maybe<Avatar>
  /** Like a username, Unique within this instance of Brickdoc */
  domain: Scalars['String']
  /** owner email */
  email?: Maybe<Scalars['String']>
  /** object unique id */
  id: Scalars['AutoIncrementID']
  /** Pod Name */
  name: Scalars['String']
  /** role */
  role: MemberRole
  /** state */
  state: MemberState
}

/** Pod operation types */
export enum PodOperation {
  /** CREATE */
  Create = 'CREATE',
  /** UPDATE */
  Update = 'UPDATE'
}

export enum Policytype {
  /** EDIT */
  Edit = 'edit',
  /** VIEW */
  View = 'view'
}

export type PreviewBox = {
  __typename?: 'PreviewBox'
  /** preview cover */
  cover?: Maybe<Scalars['String']>
  /** preview description */
  description?: Maybe<Scalars['String']>
  /** preview icon */
  icon?: Maybe<Scalars['String']>
  /** preview conetent size */
  size?: Maybe<Scalars['String']>
  /** preview title */
  title: Scalars['String']
  /** preview conetent type */
  type?: Maybe<Scalars['String']>
  /** preview url */
  url: Scalars['String']
}

/** Option Object for BrickDesign Select Component. */
export type SelectOption = {
  __typename?: 'SelectOption'
  /** option label */
  label: Scalars['String']
  /** option value */
  value: Scalars['String']
}

export type ShareLink = {
  __typename?: 'ShareLink'
  key: Scalars['String']
  policy: Policytype
  sharePodData: Pod
  state: ShareLinkState
}

/** InputObject type of Class */
export type ShareLinkInput = {
  /** block unique id */
  domain: Scalars['String']
  /** policy */
  policy: Policytype
  /** state type */
  state: ShareLinkState
}

export enum ShareLinkState {
  /** DISABLED */
  Disabled = 'disabled',
  /** ENABLED */
  Enabled = 'enabled'
}

export type SpreadsheetChildren = {
  __typename?: 'SpreadsheetChildren'
  /** blocks */
  blocks?: Maybe<Array<Block>>
}

export enum Statetype {
  /** full */
  Full = 'full',
  /** update */
  Update = 'update'
}

/** Like podMember but thin */
export type ThinUser = {
  __typename?: 'ThinUser'
  /** Pod Avatar */
  avatarData?: Maybe<Avatar>
  /** Like a username, Unique within this instance of Brickdoc */
  domain: Scalars['String']
  /** owner email */
  email?: Maybe<Scalars['String']>
  /** Pod Name */
  name: Scalars['String']
}

/** Unspash image. */
export type UnsplashImage = {
  __typename?: 'UnsplashImage'
  /** Blur hash for this image (see https://blurha.sh/) */
  blurHash?: Maybe<Scalars['String']>
  /** url for full size image */
  fullUrl: Scalars['String']
  /** Image height */
  height?: Maybe<Scalars['Int']>
  /** Unsplash image id */
  id: Scalars['String']
  /** url for small size image */
  smallUrl: Scalars['String']
  /** username */
  username?: Maybe<Scalars['String']>
  /** Image width */
  width?: Maybe<Scalars['Int']>
}

/** InputObject type of Class */
export type UpdateDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** current domain */
  domain: Scalars['String']
  /** new domain */
  newDomain: Scalars['String']
}

/** Autogenerated return type of UpdateDomain */
export type UpdateDomainPayload = {
  __typename?: 'UpdateDomainPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type UpdateMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** domain */
  domain: Scalars['String']
  /** role */
  role: MemberRole
  /** state */
  state: MemberState
}

/** Autogenerated return type of UpdateMember */
export type UpdateMemberPayload = {
  __typename?: 'UpdateMemberPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Upload types */
export enum Upload {
  /** Account avatar */
  Avatar = 'AVATAR',
  /** Page block */
  Doc = 'DOC',
  /** Third */
  Third = 'THIRD'
}

/** InputObject type of Class */
export type UserAppearanceUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** User's preferred language */
  locale?: InputMaybe<Scalars['String']>
  /** User's preferred timezone */
  timezone?: InputMaybe<Scalars['String']>
}

/** Autogenerated return type of UserAppearanceUpdate */
export type UserAppearanceUpdatePayload = {
  __typename?: 'UserAppearanceUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type UserConfirmationEmailResendInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** User's email address */
  email: Scalars['Email']
}

/** Autogenerated return type of UserConfirmationEmailResend */
export type UserConfirmationEmailResendPayload = {
  __typename?: 'UserConfirmationEmailResendPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type UserCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** Like a username, Unique within this instance of Brickdoc. */
  domain: Scalars['String']
  /** User's email address */
  email?: InputMaybe<Scalars['Email']>
  /** User's preferred language */
  locale: Scalars['String']
  /** Human-readable name of the user */
  name: Scalars['String']
  /** user password */
  password?: InputMaybe<Scalars['String']>
  /** User's preferred timezone */
  timezone: Scalars['String']
}

/** Autogenerated return type of UserCreate */
export type UserCreatePayload = {
  __typename?: 'UserCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  isUserActive?: Maybe<Scalars['Boolean']>
  /** redirect url path when sig up successful */
  redirectPath?: Maybe<Scalars['String']>
}

/** InputObject type of Class */
export type UserDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
}

/** Autogenerated return type of UserDestroy */
export type UserDestroyPayload = {
  __typename?: 'UserDestroyPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type UserEmailPasswordSignInInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** User's email address */
  email: Scalars['Email']
  /** user password */
  password: Scalars['String']
  /** remember authentication session */
  remember: Scalars['Boolean']
}

/** Autogenerated return type of UserEmailPasswordSignIn */
export type UserEmailPasswordSignInPayload = {
  __typename?: 'UserEmailPasswordSignInPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  /** redirect url path when sign in successful */
  redirectPath?: Maybe<Scalars['String']>
}

/** InputObject type of Class */
export type UserForgetPasswordMailSendInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** User's email address */
  email: Scalars['Email']
}

/** Autogenerated return type of UserForgetPasswordMailSend */
export type UserForgetPasswordMailSendPayload = {
  __typename?: 'UserForgetPasswordMailSendPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type UserPasswordResetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** Reset password */
  password: Scalars['String']
  /** Reset password token by Devise */
  token: Scalars['String']
}

/** Autogenerated return type of UserPasswordReset */
export type UserPasswordResetPayload = {
  __typename?: 'UserPasswordResetPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** InputObject type of Class */
export type UserSignOutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
}

/** Autogenerated return type of UserSignOut */
export type UserSignOutPayload = {
  __typename?: 'UserSignOutPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

export type ValidateResult = {
  __typename?: 'ValidateResult'
  /** error message */
  message: Scalars['String']
  /** Validate success */
  success: Scalars['Boolean']
}

export type BlockBaseObjectPermissions = {
  __typename?: 'blockBaseObjectPermissions'
  canShow: AuthorizationResult
}

export type Query = {
  __typename?: 'query'
  /** return single block by id. */
  block?: Maybe<Block>
  blockInfo?: Maybe<BlockInfo>
  blockNew?: Maybe<BlockNew>
  /** return all pins */
  blockPins?: Maybe<Array<Pin>>
  blockSearch?: Maybe<Array<Block>>
  /** return share links by block id. */
  blockShareLinks: Array<ShareLink>
  /** return snapshots by block id. */
  blockSnapshots?: Maybe<Array<BlockSnapshot>>
  childrenBlocks?: Maybe<Array<Block>>
  conversationComments?: Maybe<Array<Conversation>>
  currentPodDomain: Scalars['String']
  documentHistories?: Maybe<DocumentHistories>
  /** Check domain available. */
  domainAvailable: ValidateResult
  /** Check email available. */
  emailAvailable: ValidateResult
  /** provides a federated identity session data */
  federatedIdentitySession: OmniauthSession
  formulas?: Maybe<Array<Formula>>
  /** Return information about current Brickdoc server instance. */
  metadata: Metadata
  pageBlocks?: Maybe<Array<Block>>
  /** Check password available. */
  passwordAvailable: ValidateResult
  /** return current pod for user. */
  pod: Pod
  /** return all pod users */
  podMembers?: Maybe<Array<PodMember>>
  /** search pods */
  podSearch: Array<Pod>
  /** return all pods for user. */
  pods: Array<Pod>
  /** return preview box data of url */
  previewBox: PreviewBox
  spreadsheetChildren?: Maybe<SpreadsheetChildren>
  trashBlocks?: Maybe<Array<Block>>
  /** return images from unsplash by search */
  unsplashImage?: Maybe<Array<UnsplashImage>>
}

export type QueryBlockArgs = {
  id: Scalars['String']
}

export type QueryBlockInfoArgs = {
  domain: Scalars['String']
  id: Scalars['String']
}

export type QueryBlockNewArgs = {
  historyId?: InputMaybe<Scalars['String']>
  id: Scalars['String']
}

export type QueryBlockSearchArgs = {
  domain: Scalars['String']
  input: Scalars['String']
}

export type QueryBlockShareLinksArgs = {
  id: Scalars['String']
}

export type QueryBlockSnapshotsArgs = {
  id: Scalars['String']
}

export type QueryChildrenBlocksArgs = {
  rootId: Scalars['String']
  snapshotVersion: Scalars['Int']
}

export type QueryConversationCommentsArgs = {
  pageIds: Array<Scalars['UUID']>
}

export type QueryDocumentHistoriesArgs = {
  id: Scalars['String']
}

export type QueryDomainAvailableArgs = {
  domain: Scalars['String']
}

export type QueryEmailAvailableArgs = {
  email: Scalars['String']
}

export type QueryFormulasArgs = {
  domain: Scalars['String']
  ids?: InputMaybe<Scalars['String']>
}

export type QueryPageBlocksArgs = {
  domain: Scalars['String']
}

export type QueryPasswordAvailableArgs = {
  password: Scalars['String']
}

export type QueryPodArgs = {
  domain: Scalars['String']
}

export type QueryPodSearchArgs = {
  input: Scalars['String']
}

export type QueryPreviewBoxArgs = {
  url: Scalars['String']
}

export type QuerySpreadsheetChildrenArgs = {
  parentId: Scalars['String']
}

export type QueryTrashBlocksArgs = {
  blockId?: InputMaybe<Scalars['UUID']>
  domain: Scalars['String']
  search?: InputMaybe<Scalars['String']>
}

export type QueryUnsplashImageArgs = {
  page?: InputMaybe<Scalars['Int']>
  perPage?: InputMaybe<Scalars['Int']>
  query?: InputMaybe<Scalars['String']>
}

export type Subscription = {
  __typename?: 'subscription'
  document: DocumentPayload
  newPatch: NewPatchPayload
}

export type SubscriptionDocumentArgs = {
  docId: Scalars['UUID']
}

export type SubscriptionNewPatchArgs = {
  docId: Scalars['UUID']
}

export type QueryEmailAvailableFromWsQueryVariables = Exact<{
  email: Scalars['String']
}>

export type QueryEmailAvailableFromWsQuery = {
  __typename?: 'query'
  emailAvailable: { __typename?: 'ValidateResult'; success: boolean; message: string }
}

export type QueryPasswordAvailableFromWsQueryVariables = Exact<{
  password: Scalars['String']
}>

export type QueryPasswordAvailableFromWsQuery = {
  __typename?: 'query'
  passwordAvailable: { __typename?: 'ValidateResult'; success: boolean; message: string }
}

export type UserSignOutMutationVariables = Exact<{
  input: UserSignOutInput
}>

export type UserSignOutMutation = {
  __typename?: 'Mutation'
  userSignOut?: { __typename?: 'UserSignOutPayload'; errors: Array<string> } | null
}

export type GetAccountsConfigFromWsQueryVariables = Exact<{ [key: string]: never }>

export type GetAccountsConfigFromWsQuery = {
  __typename?: 'query'
  metadata: {
    __typename?: 'Metadata'
    id: string
    config: {
      __typename?: 'Config'
      userAgreementLink: string
      accountsPreferredAuthMethod: AuthMethod
      accountsEmailPasswordAuth: boolean
      accountsFederatedProviders?: Array<{ __typename?: 'FederatedProvider'; name: string; logo: string }> | null
    }
  }
}

export type UserForgetPasswordMailSendMutationVariables = Exact<{
  input: UserForgetPasswordMailSendInput
}>

export type UserForgetPasswordMailSendMutation = {
  __typename?: 'Mutation'
  userForgetPasswordMailSend?: { __typename?: 'UserForgetPasswordMailSendPayload'; errors: Array<string> } | null
}

export type UserPasswordResetMutationVariables = Exact<{
  input: UserPasswordResetInput
}>

export type UserPasswordResetMutation = {
  __typename?: 'Mutation'
  userPasswordReset?: { __typename?: 'UserPasswordResetPayload'; errors: Array<string> } | null
}

export type UserEmailPasswordSignInMutationVariables = Exact<{
  input: UserEmailPasswordSignInInput
}>

export type UserEmailPasswordSignInMutation = {
  __typename?: 'Mutation'
  userEmailPasswordSignIn?: {
    __typename?: 'UserEmailPasswordSignInPayload'
    errors: Array<string>
    redirectPath?: string | null
  } | null
}

export type GetFederatedIdentitySessionQueryVariables = Exact<{ [key: string]: never }>

export type GetFederatedIdentitySessionQuery = {
  __typename?: 'query'
  federatedIdentitySession: {
    __typename?: 'OmniauthSession'
    hasSession: boolean
    domain?: string | null
    name?: string | null
    provider?: string | null
  }
}

export type UserCreateMutationVariables = Exact<{
  input: UserCreateInput
}>

export type UserCreateMutation = {
  __typename?: 'Mutation'
  userCreate?: {
    __typename?: 'UserCreatePayload'
    errors: Array<string>
    redirectPath?: string | null
    isUserActive?: boolean | null
  } | null
}

export type UserConfirmationEmailResendMutationVariables = Exact<{
  input: UserConfirmationEmailResendInput
}>

export type UserConfirmationEmailResendMutation = {
  __typename?: 'Mutation'
  userConfirmationEmailResend?: { __typename?: 'UserConfirmationEmailResendPayload'; errors: Array<string> } | null
}

export type QueryDomainAvailableFromWsQueryVariables = Exact<{
  domain: Scalars['String']
}>

export type QueryDomainAvailableFromWsQuery = {
  __typename?: 'query'
  domainAvailable: { __typename?: 'ValidateResult'; success: boolean; message: string }
}

export type GetMetadataFromWsQueryVariables = Exact<{ [key: string]: never }>

export type GetMetadataFromWsQuery = {
  __typename?: 'query'
  metadata: {
    __typename?: 'Metadata'
    id: string
    availableTimezones: Array<string>
    availableLocales: Array<{ __typename?: 'SelectOption'; label: string; value: string }>
  }
}

export type CreateDirectUploadMutationVariables = Exact<{
  input: CreateDirectUploadInput
}>

export type CreateDirectUploadMutation = {
  __typename?: 'Mutation'
  createDirectUpload?: {
    __typename?: 'CreateDirectUploadPayload'
    directUpload: {
      __typename?: 'DirectUpload'
      uploadUrl: string
      headers: any
      blobKey: string
      viewUrl: string
      downloadUrl: string
      signedId: string
    }
  } | null
}

export type GetPodsQueryVariables = Exact<{ [key: string]: never }>

export type GetPodsQuery = {
  __typename?: 'query'
  pods: Array<{
    __typename?: 'Pod'
    id: string
    domain: string
    name?: string | null
    email?: string | null
    personal: boolean
    inviteEnable: boolean
    owned: boolean
    bio?: string | null
    avatarData?: { __typename?: 'Avatar'; url: string; downloadUrl: string; signedId: string } | null
  }>
}

export type GetPodQueryVariables = Exact<{
  domain: Scalars['String']
}>

export type GetPodQuery = {
  __typename?: 'query'
  pod: {
    __typename?: 'Pod'
    id: string
    domain: string
    name?: string | null
    personal: boolean
    inviteEnable: boolean
    inviteSecret?: string | null
    bio?: string | null
    avatarData?: { __typename?: 'Avatar'; url: string; downloadUrl: string; signedId: string } | null
  }
}

export type GetCurrentPodQueryVariables = Exact<{
  domain: Scalars['String']
}>

export type GetCurrentPodQuery = {
  __typename?: 'query'
  currentPodDomain: string
  pod: {
    __typename?: 'Pod'
    id: string
    domain: string
    name?: string | null
    personal: boolean
    owned: boolean
    inviteEnable: boolean
    inviteSecret?: string | null
    bio?: string | null
    avatarData?: { __typename?: 'Avatar'; url: string; downloadUrl: string; signedId: string } | null
  }
}

export type GetPodMembersQueryVariables = Exact<{ [key: string]: never }>

export type GetPodMembersQuery = {
  __typename?: 'query'
  podMembers?: Array<{
    __typename?: 'PodMember'
    domain: string
    email?: string | null
    name: string
    role: MemberRole
    state: MemberState
    avatarData?: { __typename?: 'Avatar'; url: string; downloadUrl: string; signedId: string } | null
  }> | null
}

export type GetBlockPinsQueryVariables = Exact<{ [key: string]: never }>

export type GetBlockPinsQuery = {
  __typename?: 'query'
  blockPins?: Array<{
    __typename?: 'Pin'
    blockId: string
    text: string
    meta: {
      __typename?: 'BlockMeta'
      icon?:
        | { __typename?: 'BlockEmoji'; type?: BlockType | null; name: string; emoji: string }
        | { __typename?: 'BlockImage'; type?: BlockType | null; source?: FileSource | null; key?: string | null }
        | null
    }
  }> | null
}

export type QueryUnsplashImageQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']>
  page?: InputMaybe<Scalars['Int']>
  perPage?: InputMaybe<Scalars['Int']>
}>

export type QueryUnsplashImageQuery = {
  __typename?: 'query'
  unsplashImage?: Array<{
    __typename?: 'UnsplashImage'
    id: string
    width?: number | null
    height?: number | null
    fullUrl: string
    smallUrl: string
    username?: string | null
    blurHash?: string | null
  }> | null
}

export type QueryPreviewBoxQueryVariables = Exact<{
  url: Scalars['String']
}>

export type QueryPreviewBoxQuery = {
  __typename?: 'query'
  previewBox: {
    __typename?: 'PreviewBox'
    url: string
    title: string
    description?: string | null
    cover?: string | null
    icon?: string | null
    type?: string | null
    size?: string | null
  }
}

export type QueryPodSearchQueryVariables = Exact<{
  input: Scalars['String']
}>

export type QueryPodSearchQuery = {
  __typename?: 'query'
  podSearch: Array<{
    __typename?: 'Pod'
    domain: string
    email?: string | null
    name?: string | null
    avatarData?: { __typename?: 'Avatar'; url: string } | null
  }>
}

export type CreateOrUpdatePodMutationVariables = Exact<{
  input: CreateOrUpdatePodInput
}>

export type CreateOrUpdatePodMutation = {
  __typename?: 'Mutation'
  createOrUpdatePod?: {
    __typename?: 'CreateOrUpdatePodPayload'
    errors: Array<string>
    pod?: {
      __typename?: 'Pod'
      domain: string
      name?: string | null
      inviteEnable: boolean
      inviteSecret?: string | null
    } | null
  } | null
}

export type JoinPodMutationVariables = Exact<{
  input: JoinPodInput
}>

export type JoinPodMutation = {
  __typename?: 'Mutation'
  joinPod?: { __typename?: 'JoinPodPayload'; errors: Array<string> } | null
}

export type UpdateMemberMutationVariables = Exact<{
  input: UpdateMemberInput
}>

export type UpdateMemberMutation = {
  __typename?: 'Mutation'
  updateMember?: { __typename?: 'UpdateMemberPayload'; errors: Array<string> } | null
}

export type GetBlockSearchQueryVariables = Exact<{
  domain: Scalars['String']
  input: Scalars['String']
}>

export type GetBlockSearchQuery = {
  __typename?: 'query'
  blockSearch?: Array<{ __typename?: 'Block'; id: string; type: string; text: string; rootId: string }> | null
}

export type GetPageBlocksQueryVariables = Exact<{
  domain: Scalars['String']
}>

export type GetPageBlocksQuery = {
  __typename?: 'query'
  pageBlocks?: Array<{
    __typename?: 'Block'
    id: string
    sort: any
    nextSort: any
    firstChildSort: any
    rootId: string
    parentId?: string | null
    type: string
    text: string
    content: Array<any>
    data: any
    meta: {
      __typename?: 'BlockMeta'
      cover?:
        | { __typename?: 'BlockColor'; type?: BlockType | null; color: string }
        | { __typename?: 'BlockImage'; type?: BlockType | null; source?: FileSource | null; key?: string | null }
        | null
      icon?:
        | { __typename?: 'BlockEmoji'; type?: BlockType | null; name: string; emoji: string }
        | { __typename?: 'BlockImage'; type?: BlockType | null; source?: FileSource | null; key?: string | null }
        | null
    }
  }> | null
}

export type GetTrashBlocksQueryVariables = Exact<{
  domain: Scalars['String']
  blockId?: InputMaybe<Scalars['UUID']>
  search?: InputMaybe<Scalars['String']>
}>

export type GetTrashBlocksQuery = {
  __typename?: 'query'
  trashBlocks?: Array<{
    __typename?: 'Block'
    id: string
    deletedAt?: any | null
    rootId: string
    parentId?: string | null
    type: string
    text: string
    pathArray: Array<{
      __typename?: 'BlockPath'
      id: string
      text: string
      icon?:
        | { __typename?: 'BlockEmoji'; type?: BlockType | null; name: string; emoji: string }
        | { __typename?: 'BlockImage'; type?: BlockType | null; source?: FileSource | null; key?: string | null }
        | null
    }>
    meta: {
      __typename?: 'BlockMeta'
      people?: {
        __typename?: 'BlockPeople'
        type?: BlockType | null
        domain: string
        name?: string | null
        avatarUrl?: string | null
      } | null
      cover?:
        | { __typename?: 'BlockColor'; type?: BlockType | null; color: string }
        | { __typename?: 'BlockImage'; type?: BlockType | null; source?: FileSource | null; key?: string | null }
        | null
      icon?:
        | { __typename?: 'BlockEmoji'; type?: BlockType | null; name: string; emoji: string }
        | { __typename?: 'BlockImage'; type?: BlockType | null; source?: FileSource | null; key?: string | null }
        | null
    }
  }> | null
}

export type GetBlockShareLinksQueryVariables = Exact<{
  id: Scalars['String']
}>

export type GetBlockShareLinksQuery = {
  __typename?: 'query'
  blockShareLinks: Array<{
    __typename?: 'ShareLink'
    key: string
    policy: Policytype
    state: ShareLinkState
    sharePodData: {
      __typename?: 'Pod'
      name?: string | null
      domain: string
      email?: string | null
      avatarData?: { __typename?: 'Avatar'; url: string } | null
    }
  }>
}

export type BlockDuplicateMutationVariables = Exact<{
  input: BlockDuplicateInput
}>

export type BlockDuplicateMutation = {
  __typename?: 'Mutation'
  blockDuplicate?: {
    __typename?: 'BlockDuplicatePayload'
    id: string
    formulaIds: Array<string>
    errors: Array<string>
  } | null
}

export type BlockSoftDeleteMutationVariables = Exact<{
  input: BlockSoftDeleteInput
}>

export type BlockSoftDeleteMutation = {
  __typename?: 'Mutation'
  blockSoftDelete?: { __typename?: 'BlockSoftDeletePayload'; errors: Array<string> } | null
}

export type BlockHardDeleteMutationVariables = Exact<{
  input: BlockHardDeleteInput
}>

export type BlockHardDeleteMutation = {
  __typename?: 'Mutation'
  blockHardDelete?: { __typename?: 'BlockHardDeletePayload'; errors: Array<string> } | null
}

export type BlockRestoreMutationVariables = Exact<{
  input: BlockRestoreInput
}>

export type BlockRestoreMutation = {
  __typename?: 'Mutation'
  blockRestore?: { __typename?: 'BlockRestorePayload'; errors: Array<string> } | null
}

export type BlockPinOrUnpinMutationVariables = Exact<{
  input: BlockPinOrUnpinInput
}>

export type BlockPinOrUnpinMutation = {
  __typename?: 'Mutation'
  blockPinOrUnpin?: { __typename?: 'BlockPinOrUnpinPayload'; errors: Array<string> } | null
}

export type BlockCreateMutationVariables = Exact<{
  input: BlockCreateInput
}>

export type BlockCreateMutation = {
  __typename?: 'Mutation'
  blockCreate?: { __typename?: 'BlockCreatePayload'; id: string; errors: Array<string> } | null
}

export type BlockCreateShareLinkMutationVariables = Exact<{
  input: BlockCreateShareLinkInput
}>

export type BlockCreateShareLinkMutation = {
  __typename?: 'Mutation'
  blockCreateShareLink?: { __typename?: 'BlockCreateShareLinkPayload'; errors: Array<string> } | null
}

export type BlockMoveMutationVariables = Exact<{
  input: BlockMoveInput
}>

export type BlockMoveMutation = {
  __typename?: 'Mutation'
  blockMove?: { __typename?: 'BlockMovePayload'; errors: Array<string> } | null
}

export type BlockRenameMutationVariables = Exact<{
  input: BlockRenameInput
}>

export type BlockRenameMutation = {
  __typename?: 'Mutation'
  blockRename?: { __typename?: 'BlockRenamePayload'; errors: Array<string> } | null
}

export type BlockSyncBatchMutationVariables = Exact<{
  input: BlockSyncBatchInput
}>

export type BlockSyncBatchMutation = {
  __typename?: 'Mutation'
  blockSyncBatch?: { __typename?: 'BlockSyncBatchPayload'; errors: Array<string> } | null
}

export type FormulaCommitMutationVariables = Exact<{
  input: FormulaCommitInput
}>

export type FormulaCommitMutation = {
  __typename?: 'Mutation'
  formulaCommit?: { __typename?: 'FormulaCommitPayload'; errors: Array<string> } | null
}

export type ConversationCommentCreateMutationVariables = Exact<{
  input: ConversationCommentCreateInput
}>

export type ConversationCommentCreateMutation = {
  __typename?: 'Mutation'
  conversationCommentCreate?: {
    __typename?: 'ConversationCommentCreatePayload'
    errors: Array<string>
    conversation: {
      __typename?: 'Conversation'
      id: string
      docId: string
      markIds: Array<string>
      blockIds: Array<string>
      latestReplyAt?: any | null
      updatedAt: any
      createdAt: any
      status: ConversationStatus
      comments: Array<{
        __typename?: 'Comment'
        id: string
        content: any
        status: CommentStatus
        createdAt: any
        updatedAt: any
        creator: {
          __typename?: 'ThinUser'
          name: string
          domain: string
          avatarData?: { __typename?: 'Avatar'; url: string; downloadUrl: string; signedId: string } | null
        }
      }>
    }
  } | null
}

export type ConversationCommentAppendMutationVariables = Exact<{
  input: ConversationCommentAppendInput
}>

export type ConversationCommentAppendMutation = {
  __typename?: 'Mutation'
  conversationCommentAppend?: {
    __typename?: 'ConversationCommentAppendPayload'
    errors: Array<string>
    comment: {
      __typename?: 'Comment'
      id: string
      content: any
      status: CommentStatus
      createdAt: any
      updatedAt: any
      creator: {
        __typename?: 'ThinUser'
        name: string
        domain: string
        avatarData?: { __typename?: 'Avatar'; url: string; downloadUrl: string; signedId: string } | null
      }
    }
  } | null
}

export type GetConversationCommentsQueryVariables = Exact<{
  pageIds: Array<Scalars['UUID']> | Scalars['UUID']
}>

export type GetConversationCommentsQuery = {
  __typename?: 'query'
  conversationComments?: Array<{
    __typename?: 'Conversation'
    id: string
    docId: string
    markIds: Array<string>
    blockIds: Array<string>
    latestReplyAt?: any | null
    updatedAt: any
    createdAt: any
    status: ConversationStatus
    comments: Array<{
      __typename?: 'Comment'
      id: string
      content: any
      status: CommentStatus
      createdAt: any
      updatedAt: any
      creator: {
        __typename?: 'ThinUser'
        name: string
        domain: string
        avatarData?: { __typename?: 'Avatar'; url: string; downloadUrl: string; signedId: string } | null
      }
    }>
  }> | null
}

export type GetFormulasQueryVariables = Exact<{
  domain: Scalars['String']
  ids?: InputMaybe<Scalars['String']>
}>

export type GetFormulasQuery = {
  __typename?: 'query'
  formulas?: Array<{
    __typename?: 'Formula'
    id: string
    name: string
    cacheValue: any
    blockId: string
    definition: string
    updatedAt: any
    createdAt: number
    version: number
    type: string
    meta: any
  }> | null
}

export type NewPatchSubscriptionVariables = Exact<{
  docId: Scalars['UUID']
}>

export type NewPatchSubscription = {
  __typename?: 'subscription'
  newPatch: {
    __typename?: 'NewPatchPayload'
    state: Patchstate
    seq: number
    patches: Array<{
      __typename?: 'PatchBaseObject'
      id: string
      path: Array<string>
      patchType: Patchtype
      payload: any
      operatorId: string
    }>
  }
}

export type GetBlockInfoQueryVariables = Exact<{
  id: Scalars['String']
  domain: Scalars['String']
}>

export type GetBlockInfoQuery = {
  __typename?: 'query'
  blockInfo?: {
    __typename?: 'BlockInfo'
    title: string
    id: string
    isDeleted: boolean
    isMaster: boolean
    pin: boolean
    enabledAlias?: { __typename?: 'BlockAlias'; key: string; payload: any } | null
    icon?:
      | { __typename?: 'BlockEmoji'; type?: BlockType | null; name: string; emoji: string }
      | {
          __typename?: 'BlockImage'
          type?: BlockType | null
          source?: FileSource | null
          key?: string | null
          height?: number | null
          width?: number | null
        }
      | null
    pathArray: Array<{
      __typename?: 'BlockPath'
      id: string
      text: string
      icon?:
        | { __typename?: 'BlockEmoji'; type?: BlockType | null; name: string; emoji: string }
        | {
            __typename?: 'BlockImage'
            type?: BlockType | null
            source?: FileSource | null
            key?: string | null
            height?: number | null
            width?: number | null
          }
        | null
    }>
    permission?: { __typename?: 'ShareLink'; key: string; policy: Policytype; state: ShareLinkState } | null
    collaborators: Array<{
      __typename?: 'Pod'
      name?: string | null
      domain: string
      email?: string | null
      avatarData?: { __typename?: 'Avatar'; url: string } | null
    }>
  } | null
}

export type GetChildrenBlocksQueryVariables = Exact<{
  rootId: Scalars['String']
  snapshotVersion: Scalars['Int']
}>

export type GetChildrenBlocksQuery = {
  __typename?: 'query'
  childrenBlocks?: Array<{
    __typename?: 'Block'
    id: string
    sort: any
    parentId?: string | null
    deletedAt?: any | null
    rootId: string
    type: string
    text: string
    content: Array<any>
    data: any
    blobs?: Array<{ __typename?: 'Blob'; blobKey: string; downloadUrl: string; url: string }> | null
    meta: {
      __typename?: 'BlockMeta'
      title?: string | null
      level?: number | null
      language?: string | null
      autoWrap?: boolean | null
      start?: string | null
      image?: {
        __typename?: 'BlockImage'
        type?: BlockType | null
        source?: FileSource | null
        key?: string | null
        viewUrl?: string | null
        displayName?: string | null
        height?: number | null
        width?: number | null
        ratio?: number | null
        mode?: string | null
        name?: string | null
        size?: number | null
        align?: string | null
      } | null
      page?: {
        __typename?: 'BlockPage'
        type?: BlockType | null
        key: string
        title?: string | null
        icon?: string | null
        link: string
      } | null
      people?: {
        __typename?: 'BlockPeople'
        type?: BlockType | null
        domain: string
        name?: string | null
        avatarUrl?: string | null
      } | null
      embedMeta?: { __typename?: 'BlockEmbedMeta'; type?: string | null; embedType?: EmbedType | null } | null
      attachment?: {
        __typename?: 'BlockAttachment'
        type: BlockType
        source?: FileSource | null
        key?: string | null
        viewUrl?: string | null
        height?: number | null
        width?: number | null
        name?: string | null
        displayName?: string | null
        size?: number | null
        mode?: string | null
      } | null
      cover?:
        | { __typename?: 'BlockColor'; type?: BlockType | null; color: string }
        | {
            __typename?: 'BlockImage'
            type?: BlockType | null
            source?: FileSource | null
            key?: string | null
            height?: number | null
            width?: number | null
          }
        | null
      icon?:
        | { __typename?: 'BlockEmoji'; type?: BlockType | null; name: string; emoji: string }
        | {
            __typename?: 'BlockImage'
            type?: BlockType | null
            source?: FileSource | null
            key?: string | null
            height?: number | null
            width?: number | null
          }
        | null
      link?: {
        __typename?: 'BlockLink'
        key?: string | null
        type: string
        source?: FileSource | null
        cover?: string | null
        description?: string | null
        title?: string | null
        displayName?: string | null
        icon?: string | null
        mode?: string | null
      } | null
    }
  }> | null
}

export type GetSpreadsheetChildrenQueryVariables = Exact<{
  parentId: Scalars['String']
}>

export type GetSpreadsheetChildrenQuery = {
  __typename?: 'query'
  spreadsheetChildren?: {
    __typename?: 'SpreadsheetChildren'
    blocks?: Array<{
      __typename?: 'Block'
      id: string
      sort: any
      parentId?: string | null
      type: string
      text: string
      content: Array<any>
      data: any
    }> | null
  } | null
}

export type BlockNewQueryVariables = Exact<{
  id: Scalars['String']
  historyId?: InputMaybe<Scalars['String']>
}>

export type BlockNewQuery = {
  __typename?: 'query'
  blockNew?: {
    __typename?: 'BlockNew'
    id: string
    statesCount?: number | null
    stateId?: string | null
    blockType?: string | null
    states?: Array<{ __typename?: 'BlockState'; id: string; state?: string | null }> | null
  } | null
}

export type DocumentHistoriesQueryVariables = Exact<{
  id: Scalars['String']
}>

export type DocumentHistoriesQuery = {
  __typename?: 'query'
  documentHistories?: {
    __typename?: 'DocumentHistories'
    users?: Array<{ __typename?: 'ThinUser'; name: string }> | null
    histories?: Array<{ __typename?: 'DocumentHistory'; id: string; createdAt: any; username: string }> | null
  } | null
}

export type BlockCommitMutationVariables = Exact<{
  input: BlockCommitInput
}>

export type BlockCommitMutation = {
  __typename?: 'Mutation'
  blockCommit?: {
    __typename?: 'BlockCommitPayload'
    errors: Array<string>
    requireFull?: boolean | null
    block?: {
      __typename?: 'BlockNew'
      id: string
      statesCount?: number | null
      stateId?: string | null
      blockType?: string | null
    } | null
    diffStates?: Array<{ __typename?: 'BlockState'; id: string; state?: string | null; createdAt: any }> | null
  } | null
}

export type DocumentSubscriptionVariables = Exact<{
  docId: Scalars['UUID']
}>

export type DocumentSubscription = {
  __typename?: 'subscription'
  document: {
    __typename?: 'DocumentPayload'
    operatorId?: string | null
    blocks?: Array<{
      __typename?: 'BlockNew'
      id: string
      statesCount?: number | null
      stateId?: string | null
      blockType?: string | null
    }> | null
    states?: Array<{
      __typename?: 'BlockState'
      id: string
      state?: string | null
      createdAt: any
      blockId?: string | null
    }> | null
    histories?: Array<{ __typename?: 'DocumentHistory'; id: string; createdAt: any; username: string }> | null
  }
}

export type UpdateDomainMutationVariables = Exact<{
  input: UpdateDomainInput
}>

export type UpdateDomainMutation = {
  __typename?: 'Mutation'
  updateDomain?: { __typename?: 'UpdateDomainPayload'; errors: Array<string> } | null
}

export type UserAppearanceUpdateMutationVariables = Exact<{
  input: UserAppearanceUpdateInput
}>

export type UserAppearanceUpdateMutation = {
  __typename?: 'Mutation'
  userAppearanceUpdate?: { __typename?: 'UserAppearanceUpdatePayload'; errors: Array<string> } | null
}

export type UserDestroyMutationVariables = Exact<{
  input: UserDestroyInput
}>

export type UserDestroyMutation = {
  __typename?: 'Mutation'
  userDestroy?: { __typename?: 'UserDestroyPayload'; errors: Array<string> } | null
}

export type PodDestroyMutationVariables = Exact<{
  input: PodDestroyInput
}>

export type PodDestroyMutation = {
  __typename?: 'Mutation'
  podDestroy?: { __typename?: 'PodDestroyPayload'; errors: Array<string> } | null
}

export type PodLeaveMutationVariables = Exact<{
  input: PodLeaveInput
}>

export type PodLeaveMutation = {
  __typename?: 'Mutation'
  podLeave?: { __typename?: 'PodLeavePayload'; errors: Array<string> } | null
}

export const QueryEmailAvailableFromWsDocument = gql`
  query QueryEmailAvailableFromWS($email: String!) {
    emailAvailable(email: $email) {
      success
      message
    }
  }
`

/**
 * __useQueryEmailAvailableFromWsQuery__
 *
 * To run a query within a React component, call `useQueryEmailAvailableFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryEmailAvailableFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryEmailAvailableFromWsQuery({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export function useQueryEmailAvailableFromWsQuery(
  baseOptions: Apollo.QueryHookOptions<QueryEmailAvailableFromWsQuery, QueryEmailAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryEmailAvailableFromWsQuery, QueryEmailAvailableFromWsQueryVariables>(
    QueryEmailAvailableFromWsDocument,
    options
  )
}
export function useQueryEmailAvailableFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryEmailAvailableFromWsQuery, QueryEmailAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryEmailAvailableFromWsQuery, QueryEmailAvailableFromWsQueryVariables>(
    QueryEmailAvailableFromWsDocument,
    options
  )
}
export type QueryEmailAvailableFromWsQueryHookResult = ReturnType<typeof useQueryEmailAvailableFromWsQuery>
export type QueryEmailAvailableFromWsLazyQueryHookResult = ReturnType<typeof useQueryEmailAvailableFromWsLazyQuery>
export type QueryEmailAvailableFromWsQueryResult = Apollo.QueryResult<
  QueryEmailAvailableFromWsQuery,
  QueryEmailAvailableFromWsQueryVariables
>
export const QueryPasswordAvailableFromWsDocument = gql`
  query QueryPasswordAvailableFromWS($password: String!) {
    passwordAvailable(password: $password) {
      success
      message
    }
  }
`

/**
 * __useQueryPasswordAvailableFromWsQuery__
 *
 * To run a query within a React component, call `useQueryPasswordAvailableFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryPasswordAvailableFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryPasswordAvailableFromWsQuery({
 *   variables: {
 *      password: // value for 'password'
 *   },
 * });
 */
export function useQueryPasswordAvailableFromWsQuery(
  baseOptions: Apollo.QueryHookOptions<QueryPasswordAvailableFromWsQuery, QueryPasswordAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryPasswordAvailableFromWsQuery, QueryPasswordAvailableFromWsQueryVariables>(
    QueryPasswordAvailableFromWsDocument,
    options
  )
}
export function useQueryPasswordAvailableFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    QueryPasswordAvailableFromWsQuery,
    QueryPasswordAvailableFromWsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryPasswordAvailableFromWsQuery, QueryPasswordAvailableFromWsQueryVariables>(
    QueryPasswordAvailableFromWsDocument,
    options
  )
}
export type QueryPasswordAvailableFromWsQueryHookResult = ReturnType<typeof useQueryPasswordAvailableFromWsQuery>
export type QueryPasswordAvailableFromWsLazyQueryHookResult = ReturnType<
  typeof useQueryPasswordAvailableFromWsLazyQuery
>
export type QueryPasswordAvailableFromWsQueryResult = Apollo.QueryResult<
  QueryPasswordAvailableFromWsQuery,
  QueryPasswordAvailableFromWsQueryVariables
>
export const UserSignOutDocument = gql`
  mutation userSignOut($input: UserSignOutInput!) {
    userSignOut(input: $input) {
      errors
    }
  }
`
export type UserSignOutMutationFn = Apollo.MutationFunction<UserSignOutMutation, UserSignOutMutationVariables>

/**
 * __useUserSignOutMutation__
 *
 * To run a mutation, you first call `useUserSignOutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserSignOutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userSignOutMutation, { data, loading, error }] = useUserSignOutMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserSignOutMutation(
  baseOptions?: Apollo.MutationHookOptions<UserSignOutMutation, UserSignOutMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserSignOutMutation, UserSignOutMutationVariables>(UserSignOutDocument, options)
}
export type UserSignOutMutationHookResult = ReturnType<typeof useUserSignOutMutation>
export type UserSignOutMutationResult = Apollo.MutationResult<UserSignOutMutation>
export type UserSignOutMutationOptions = Apollo.BaseMutationOptions<UserSignOutMutation, UserSignOutMutationVariables>
export const GetAccountsConfigFromWsDocument = gql`
  query GetAccountsConfigFromWS {
    metadata {
      id
      config {
        userAgreementLink
        accountsPreferredAuthMethod
        accountsEmailPasswordAuth
        accountsFederatedProviders {
          name
          logo
        }
      }
    }
  }
`

/**
 * __useGetAccountsConfigFromWsQuery__
 *
 * To run a query within a React component, call `useGetAccountsConfigFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAccountsConfigFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAccountsConfigFromWsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAccountsConfigFromWsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>(
    GetAccountsConfigFromWsDocument,
    options
  )
}
export function useGetAccountsConfigFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>(
    GetAccountsConfigFromWsDocument,
    options
  )
}
export type GetAccountsConfigFromWsQueryHookResult = ReturnType<typeof useGetAccountsConfigFromWsQuery>
export type GetAccountsConfigFromWsLazyQueryHookResult = ReturnType<typeof useGetAccountsConfigFromWsLazyQuery>
export type GetAccountsConfigFromWsQueryResult = Apollo.QueryResult<
  GetAccountsConfigFromWsQuery,
  GetAccountsConfigFromWsQueryVariables
>
export const UserForgetPasswordMailSendDocument = gql`
  mutation userForgetPasswordMailSend($input: UserForgetPasswordMailSendInput!) {
    userForgetPasswordMailSend(input: $input) {
      errors
    }
  }
`
export type UserForgetPasswordMailSendMutationFn = Apollo.MutationFunction<
  UserForgetPasswordMailSendMutation,
  UserForgetPasswordMailSendMutationVariables
>

/**
 * __useUserForgetPasswordMailSendMutation__
 *
 * To run a mutation, you first call `useUserForgetPasswordMailSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserForgetPasswordMailSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userForgetPasswordMailSendMutation, { data, loading, error }] = useUserForgetPasswordMailSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserForgetPasswordMailSendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserForgetPasswordMailSendMutation,
    UserForgetPasswordMailSendMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserForgetPasswordMailSendMutation, UserForgetPasswordMailSendMutationVariables>(
    UserForgetPasswordMailSendDocument,
    options
  )
}
export type UserForgetPasswordMailSendMutationHookResult = ReturnType<typeof useUserForgetPasswordMailSendMutation>
export type UserForgetPasswordMailSendMutationResult = Apollo.MutationResult<UserForgetPasswordMailSendMutation>
export type UserForgetPasswordMailSendMutationOptions = Apollo.BaseMutationOptions<
  UserForgetPasswordMailSendMutation,
  UserForgetPasswordMailSendMutationVariables
>
export const UserPasswordResetDocument = gql`
  mutation userPasswordReset($input: UserPasswordResetInput!) {
    userPasswordReset(input: $input) {
      errors
    }
  }
`
export type UserPasswordResetMutationFn = Apollo.MutationFunction<
  UserPasswordResetMutation,
  UserPasswordResetMutationVariables
>

/**
 * __useUserPasswordResetMutation__
 *
 * To run a mutation, you first call `useUserPasswordResetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPasswordResetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPasswordResetMutation, { data, loading, error }] = useUserPasswordResetMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserPasswordResetMutation(
  baseOptions?: Apollo.MutationHookOptions<UserPasswordResetMutation, UserPasswordResetMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserPasswordResetMutation, UserPasswordResetMutationVariables>(
    UserPasswordResetDocument,
    options
  )
}
export type UserPasswordResetMutationHookResult = ReturnType<typeof useUserPasswordResetMutation>
export type UserPasswordResetMutationResult = Apollo.MutationResult<UserPasswordResetMutation>
export type UserPasswordResetMutationOptions = Apollo.BaseMutationOptions<
  UserPasswordResetMutation,
  UserPasswordResetMutationVariables
>
export const UserEmailPasswordSignInDocument = gql`
  mutation userEmailPasswordSignIn($input: UserEmailPasswordSignInInput!) {
    userEmailPasswordSignIn(input: $input) {
      errors
      redirectPath
    }
  }
`
export type UserEmailPasswordSignInMutationFn = Apollo.MutationFunction<
  UserEmailPasswordSignInMutation,
  UserEmailPasswordSignInMutationVariables
>

/**
 * __useUserEmailPasswordSignInMutation__
 *
 * To run a mutation, you first call `useUserEmailPasswordSignInMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailPasswordSignInMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailPasswordSignInMutation, { data, loading, error }] = useUserEmailPasswordSignInMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserEmailPasswordSignInMutation(
  baseOptions?: Apollo.MutationHookOptions<UserEmailPasswordSignInMutation, UserEmailPasswordSignInMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserEmailPasswordSignInMutation, UserEmailPasswordSignInMutationVariables>(
    UserEmailPasswordSignInDocument,
    options
  )
}
export type UserEmailPasswordSignInMutationHookResult = ReturnType<typeof useUserEmailPasswordSignInMutation>
export type UserEmailPasswordSignInMutationResult = Apollo.MutationResult<UserEmailPasswordSignInMutation>
export type UserEmailPasswordSignInMutationOptions = Apollo.BaseMutationOptions<
  UserEmailPasswordSignInMutation,
  UserEmailPasswordSignInMutationVariables
>
export const GetFederatedIdentitySessionDocument = gql`
  query GetFederatedIdentitySession {
    federatedIdentitySession {
      hasSession
      domain
      name
      provider
    }
  }
`

/**
 * __useGetFederatedIdentitySessionQuery__
 *
 * To run a query within a React component, call `useGetFederatedIdentitySessionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFederatedIdentitySessionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFederatedIdentitySessionQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetFederatedIdentitySessionQuery(
  baseOptions?: Apollo.QueryHookOptions<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>(
    GetFederatedIdentitySessionDocument,
    options
  )
}
export function useGetFederatedIdentitySessionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>(
    GetFederatedIdentitySessionDocument,
    options
  )
}
export type GetFederatedIdentitySessionQueryHookResult = ReturnType<typeof useGetFederatedIdentitySessionQuery>
export type GetFederatedIdentitySessionLazyQueryHookResult = ReturnType<typeof useGetFederatedIdentitySessionLazyQuery>
export type GetFederatedIdentitySessionQueryResult = Apollo.QueryResult<
  GetFederatedIdentitySessionQuery,
  GetFederatedIdentitySessionQueryVariables
>
export const UserCreateDocument = gql`
  mutation userCreate($input: UserCreateInput!) {
    userCreate(input: $input) {
      errors
      redirectPath
      isUserActive
    }
  }
`
export type UserCreateMutationFn = Apollo.MutationFunction<UserCreateMutation, UserCreateMutationVariables>

/**
 * __useUserCreateMutation__
 *
 * To run a mutation, you first call `useUserCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userCreateMutation, { data, loading, error }] = useUserCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<UserCreateMutation, UserCreateMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserCreateMutation, UserCreateMutationVariables>(UserCreateDocument, options)
}
export type UserCreateMutationHookResult = ReturnType<typeof useUserCreateMutation>
export type UserCreateMutationResult = Apollo.MutationResult<UserCreateMutation>
export type UserCreateMutationOptions = Apollo.BaseMutationOptions<UserCreateMutation, UserCreateMutationVariables>
export const UserConfirmationEmailResendDocument = gql`
  mutation userConfirmationEmailResend($input: UserConfirmationEmailResendInput!) {
    userConfirmationEmailResend(input: $input) {
      errors
    }
  }
`
export type UserConfirmationEmailResendMutationFn = Apollo.MutationFunction<
  UserConfirmationEmailResendMutation,
  UserConfirmationEmailResendMutationVariables
>

/**
 * __useUserConfirmationEmailResendMutation__
 *
 * To run a mutation, you first call `useUserConfirmationEmailResendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserConfirmationEmailResendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userConfirmationEmailResendMutation, { data, loading, error }] = useUserConfirmationEmailResendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserConfirmationEmailResendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserConfirmationEmailResendMutation,
    UserConfirmationEmailResendMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserConfirmationEmailResendMutation, UserConfirmationEmailResendMutationVariables>(
    UserConfirmationEmailResendDocument,
    options
  )
}
export type UserConfirmationEmailResendMutationHookResult = ReturnType<typeof useUserConfirmationEmailResendMutation>
export type UserConfirmationEmailResendMutationResult = Apollo.MutationResult<UserConfirmationEmailResendMutation>
export type UserConfirmationEmailResendMutationOptions = Apollo.BaseMutationOptions<
  UserConfirmationEmailResendMutation,
  UserConfirmationEmailResendMutationVariables
>
export const QueryDomainAvailableFromWsDocument = gql`
  query QueryDomainAvailableFromWS($domain: String!) {
    domainAvailable(domain: $domain) {
      success
      message
    }
  }
`

/**
 * __useQueryDomainAvailableFromWsQuery__
 *
 * To run a query within a React component, call `useQueryDomainAvailableFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryDomainAvailableFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryDomainAvailableFromWsQuery({
 *   variables: {
 *      domain: // value for 'domain'
 *   },
 * });
 */
export function useQueryDomainAvailableFromWsQuery(
  baseOptions: Apollo.QueryHookOptions<QueryDomainAvailableFromWsQuery, QueryDomainAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryDomainAvailableFromWsQuery, QueryDomainAvailableFromWsQueryVariables>(
    QueryDomainAvailableFromWsDocument,
    options
  )
}
export function useQueryDomainAvailableFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryDomainAvailableFromWsQuery, QueryDomainAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryDomainAvailableFromWsQuery, QueryDomainAvailableFromWsQueryVariables>(
    QueryDomainAvailableFromWsDocument,
    options
  )
}
export type QueryDomainAvailableFromWsQueryHookResult = ReturnType<typeof useQueryDomainAvailableFromWsQuery>
export type QueryDomainAvailableFromWsLazyQueryHookResult = ReturnType<typeof useQueryDomainAvailableFromWsLazyQuery>
export type QueryDomainAvailableFromWsQueryResult = Apollo.QueryResult<
  QueryDomainAvailableFromWsQuery,
  QueryDomainAvailableFromWsQueryVariables
>
export const GetMetadataFromWsDocument = gql`
  query GetMetadataFromWS {
    metadata {
      id
      availableLocales {
        label
        value
      }
      availableTimezones
    }
  }
`

/**
 * __useGetMetadataFromWsQuery__
 *
 * To run a query within a React component, call `useGetMetadataFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMetadataFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMetadataFromWsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetMetadataFromWsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetMetadataFromWsQuery, GetMetadataFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetMetadataFromWsQuery, GetMetadataFromWsQueryVariables>(GetMetadataFromWsDocument, options)
}
export function useGetMetadataFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetMetadataFromWsQuery, GetMetadataFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetMetadataFromWsQuery, GetMetadataFromWsQueryVariables>(
    GetMetadataFromWsDocument,
    options
  )
}
export type GetMetadataFromWsQueryHookResult = ReturnType<typeof useGetMetadataFromWsQuery>
export type GetMetadataFromWsLazyQueryHookResult = ReturnType<typeof useGetMetadataFromWsLazyQuery>
export type GetMetadataFromWsQueryResult = Apollo.QueryResult<GetMetadataFromWsQuery, GetMetadataFromWsQueryVariables>
export const CreateDirectUploadDocument = gql`
  mutation createDirectUpload($input: CreateDirectUploadInput!) {
    createDirectUpload(input: $input) {
      directUpload {
        uploadUrl
        headers
        blobKey
        viewUrl
        downloadUrl
        signedId
      }
    }
  }
`
export type CreateDirectUploadMutationFn = Apollo.MutationFunction<
  CreateDirectUploadMutation,
  CreateDirectUploadMutationVariables
>

/**
 * __useCreateDirectUploadMutation__
 *
 * To run a mutation, you first call `useCreateDirectUploadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDirectUploadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDirectUploadMutation, { data, loading, error }] = useCreateDirectUploadMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateDirectUploadMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateDirectUploadMutation, CreateDirectUploadMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateDirectUploadMutation, CreateDirectUploadMutationVariables>(
    CreateDirectUploadDocument,
    options
  )
}
export type CreateDirectUploadMutationHookResult = ReturnType<typeof useCreateDirectUploadMutation>
export type CreateDirectUploadMutationResult = Apollo.MutationResult<CreateDirectUploadMutation>
export type CreateDirectUploadMutationOptions = Apollo.BaseMutationOptions<
  CreateDirectUploadMutation,
  CreateDirectUploadMutationVariables
>
export const GetPodsDocument = gql`
  query GetPods {
    pods {
      id
      domain
      name
      email
      personal
      inviteEnable
      owned
      avatarData {
        url
        downloadUrl
        signedId
      }
      bio
    }
  }
`

/**
 * __useGetPodsQuery__
 *
 * To run a query within a React component, call `useGetPodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPodsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPodsQuery(baseOptions?: Apollo.QueryHookOptions<GetPodsQuery, GetPodsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPodsQuery, GetPodsQueryVariables>(GetPodsDocument, options)
}
export function useGetPodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPodsQuery, GetPodsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPodsQuery, GetPodsQueryVariables>(GetPodsDocument, options)
}
export type GetPodsQueryHookResult = ReturnType<typeof useGetPodsQuery>
export type GetPodsLazyQueryHookResult = ReturnType<typeof useGetPodsLazyQuery>
export type GetPodsQueryResult = Apollo.QueryResult<GetPodsQuery, GetPodsQueryVariables>
export const GetPodDocument = gql`
  query GetPod($domain: String!) {
    pod(domain: $domain) {
      id
      domain
      name
      personal
      inviteEnable
      inviteSecret
      avatarData {
        url
        downloadUrl
        signedId
      }
      bio
    }
  }
`

/**
 * __useGetPodQuery__
 *
 * To run a query within a React component, call `useGetPodQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPodQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPodQuery({
 *   variables: {
 *      domain: // value for 'domain'
 *   },
 * });
 */
export function useGetPodQuery(baseOptions: Apollo.QueryHookOptions<GetPodQuery, GetPodQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPodQuery, GetPodQueryVariables>(GetPodDocument, options)
}
export function useGetPodLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPodQuery, GetPodQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPodQuery, GetPodQueryVariables>(GetPodDocument, options)
}
export type GetPodQueryHookResult = ReturnType<typeof useGetPodQuery>
export type GetPodLazyQueryHookResult = ReturnType<typeof useGetPodLazyQuery>
export type GetPodQueryResult = Apollo.QueryResult<GetPodQuery, GetPodQueryVariables>
export const GetCurrentPodDocument = gql`
  query GetCurrentPod($domain: String!) {
    currentPodDomain @client @export(as: "domain")
    pod(domain: $domain) {
      id
      domain
      name
      personal
      owned
      inviteEnable
      inviteSecret
      avatarData {
        url
        downloadUrl
        signedId
      }
      bio
    }
  }
`

/**
 * __useGetCurrentPodQuery__
 *
 * To run a query within a React component, call `useGetCurrentPodQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentPodQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentPodQuery({
 *   variables: {
 *      domain: // value for 'domain'
 *   },
 * });
 */
export function useGetCurrentPodQuery(
  baseOptions: Apollo.QueryHookOptions<GetCurrentPodQuery, GetCurrentPodQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetCurrentPodQuery, GetCurrentPodQueryVariables>(GetCurrentPodDocument, options)
}
export function useGetCurrentPodLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentPodQuery, GetCurrentPodQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetCurrentPodQuery, GetCurrentPodQueryVariables>(GetCurrentPodDocument, options)
}
export type GetCurrentPodQueryHookResult = ReturnType<typeof useGetCurrentPodQuery>
export type GetCurrentPodLazyQueryHookResult = ReturnType<typeof useGetCurrentPodLazyQuery>
export type GetCurrentPodQueryResult = Apollo.QueryResult<GetCurrentPodQuery, GetCurrentPodQueryVariables>
export const GetPodMembersDocument = gql`
  query GetPodMembers {
    podMembers {
      domain
      email
      name
      role
      state
      avatarData {
        url
        downloadUrl
        signedId
      }
    }
  }
`

/**
 * __useGetPodMembersQuery__
 *
 * To run a query within a React component, call `useGetPodMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPodMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPodMembersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPodMembersQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPodMembersQuery, GetPodMembersQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPodMembersQuery, GetPodMembersQueryVariables>(GetPodMembersDocument, options)
}
export function useGetPodMembersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPodMembersQuery, GetPodMembersQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPodMembersQuery, GetPodMembersQueryVariables>(GetPodMembersDocument, options)
}
export type GetPodMembersQueryHookResult = ReturnType<typeof useGetPodMembersQuery>
export type GetPodMembersLazyQueryHookResult = ReturnType<typeof useGetPodMembersLazyQuery>
export type GetPodMembersQueryResult = Apollo.QueryResult<GetPodMembersQuery, GetPodMembersQueryVariables>
export const GetBlockPinsDocument = gql`
  query GetBlockPins {
    blockPins {
      blockId
      text
      meta {
        icon {
          ... on BlockImage {
            type
            source
            key
          }
          ... on BlockEmoji {
            type
            name
            emoji
          }
        }
      }
    }
  }
`

/**
 * __useGetBlockPinsQuery__
 *
 * To run a query within a React component, call `useGetBlockPinsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBlockPinsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBlockPinsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetBlockPinsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetBlockPinsQuery, GetBlockPinsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBlockPinsQuery, GetBlockPinsQueryVariables>(GetBlockPinsDocument, options)
}
export function useGetBlockPinsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetBlockPinsQuery, GetBlockPinsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBlockPinsQuery, GetBlockPinsQueryVariables>(GetBlockPinsDocument, options)
}
export type GetBlockPinsQueryHookResult = ReturnType<typeof useGetBlockPinsQuery>
export type GetBlockPinsLazyQueryHookResult = ReturnType<typeof useGetBlockPinsLazyQuery>
export type GetBlockPinsQueryResult = Apollo.QueryResult<GetBlockPinsQuery, GetBlockPinsQueryVariables>
export const QueryUnsplashImageDocument = gql`
  query QueryUnsplashImage($query: String, $page: Int, $perPage: Int) {
    unsplashImage(query: $query, page: $page, perPage: $perPage) {
      id
      width
      height
      fullUrl
      smallUrl
      username
      blurHash
    }
  }
`

/**
 * __useQueryUnsplashImageQuery__
 *
 * To run a query within a React component, call `useQueryUnsplashImageQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryUnsplashImageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryUnsplashImageQuery({
 *   variables: {
 *      query: // value for 'query'
 *      page: // value for 'page'
 *      perPage: // value for 'perPage'
 *   },
 * });
 */
export function useQueryUnsplashImageQuery(
  baseOptions?: Apollo.QueryHookOptions<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>(QueryUnsplashImageDocument, options)
}
export function useQueryUnsplashImageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryUnsplashImageQuery, QueryUnsplashImageQueryVariables>(
    QueryUnsplashImageDocument,
    options
  )
}
export type QueryUnsplashImageQueryHookResult = ReturnType<typeof useQueryUnsplashImageQuery>
export type QueryUnsplashImageLazyQueryHookResult = ReturnType<typeof useQueryUnsplashImageLazyQuery>
export type QueryUnsplashImageQueryResult = Apollo.QueryResult<
  QueryUnsplashImageQuery,
  QueryUnsplashImageQueryVariables
>
export const QueryPreviewBoxDocument = gql`
  query QueryPreviewBox($url: String!) {
    previewBox(url: $url) {
      url
      title
      description
      cover
      icon
      type
      size
    }
  }
`

/**
 * __useQueryPreviewBoxQuery__
 *
 * To run a query within a React component, call `useQueryPreviewBoxQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryPreviewBoxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryPreviewBoxQuery({
 *   variables: {
 *      url: // value for 'url'
 *   },
 * });
 */
export function useQueryPreviewBoxQuery(
  baseOptions: Apollo.QueryHookOptions<QueryPreviewBoxQuery, QueryPreviewBoxQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryPreviewBoxQuery, QueryPreviewBoxQueryVariables>(QueryPreviewBoxDocument, options)
}
export function useQueryPreviewBoxLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryPreviewBoxQuery, QueryPreviewBoxQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryPreviewBoxQuery, QueryPreviewBoxQueryVariables>(QueryPreviewBoxDocument, options)
}
export type QueryPreviewBoxQueryHookResult = ReturnType<typeof useQueryPreviewBoxQuery>
export type QueryPreviewBoxLazyQueryHookResult = ReturnType<typeof useQueryPreviewBoxLazyQuery>
export type QueryPreviewBoxQueryResult = Apollo.QueryResult<QueryPreviewBoxQuery, QueryPreviewBoxQueryVariables>
export const QueryPodSearchDocument = gql`
  query QueryPodSearch($input: String!) {
    podSearch(input: $input) {
      domain
      email
      name
      avatarData {
        url
      }
    }
  }
`

/**
 * __useQueryPodSearchQuery__
 *
 * To run a query within a React component, call `useQueryPodSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryPodSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryPodSearchQuery({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useQueryPodSearchQuery(
  baseOptions: Apollo.QueryHookOptions<QueryPodSearchQuery, QueryPodSearchQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryPodSearchQuery, QueryPodSearchQueryVariables>(QueryPodSearchDocument, options)
}
export function useQueryPodSearchLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryPodSearchQuery, QueryPodSearchQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryPodSearchQuery, QueryPodSearchQueryVariables>(QueryPodSearchDocument, options)
}
export type QueryPodSearchQueryHookResult = ReturnType<typeof useQueryPodSearchQuery>
export type QueryPodSearchLazyQueryHookResult = ReturnType<typeof useQueryPodSearchLazyQuery>
export type QueryPodSearchQueryResult = Apollo.QueryResult<QueryPodSearchQuery, QueryPodSearchQueryVariables>
export const CreateOrUpdatePodDocument = gql`
  mutation createOrUpdatePod($input: CreateOrUpdatePodInput!) {
    createOrUpdatePod(input: $input) {
      errors
      pod {
        domain
        name
        inviteEnable
        inviteSecret
      }
    }
  }
`
export type CreateOrUpdatePodMutationFn = Apollo.MutationFunction<
  CreateOrUpdatePodMutation,
  CreateOrUpdatePodMutationVariables
>

/**
 * __useCreateOrUpdatePodMutation__
 *
 * To run a mutation, you first call `useCreateOrUpdatePodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrUpdatePodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrUpdatePodMutation, { data, loading, error }] = useCreateOrUpdatePodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateOrUpdatePodMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateOrUpdatePodMutation, CreateOrUpdatePodMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateOrUpdatePodMutation, CreateOrUpdatePodMutationVariables>(
    CreateOrUpdatePodDocument,
    options
  )
}
export type CreateOrUpdatePodMutationHookResult = ReturnType<typeof useCreateOrUpdatePodMutation>
export type CreateOrUpdatePodMutationResult = Apollo.MutationResult<CreateOrUpdatePodMutation>
export type CreateOrUpdatePodMutationOptions = Apollo.BaseMutationOptions<
  CreateOrUpdatePodMutation,
  CreateOrUpdatePodMutationVariables
>
export const JoinPodDocument = gql`
  mutation joinPod($input: JoinPodInput!) {
    joinPod(input: $input) {
      errors
    }
  }
`
export type JoinPodMutationFn = Apollo.MutationFunction<JoinPodMutation, JoinPodMutationVariables>

/**
 * __useJoinPodMutation__
 *
 * To run a mutation, you first call `useJoinPodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinPodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinPodMutation, { data, loading, error }] = useJoinPodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useJoinPodMutation(
  baseOptions?: Apollo.MutationHookOptions<JoinPodMutation, JoinPodMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<JoinPodMutation, JoinPodMutationVariables>(JoinPodDocument, options)
}
export type JoinPodMutationHookResult = ReturnType<typeof useJoinPodMutation>
export type JoinPodMutationResult = Apollo.MutationResult<JoinPodMutation>
export type JoinPodMutationOptions = Apollo.BaseMutationOptions<JoinPodMutation, JoinPodMutationVariables>
export const UpdateMemberDocument = gql`
  mutation updateMember($input: UpdateMemberInput!) {
    updateMember(input: $input) {
      errors
    }
  }
`
export type UpdateMemberMutationFn = Apollo.MutationFunction<UpdateMemberMutation, UpdateMemberMutationVariables>

/**
 * __useUpdateMemberMutation__
 *
 * To run a mutation, you first call `useUpdateMemberMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMemberMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMemberMutation, { data, loading, error }] = useUpdateMemberMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMemberMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateMemberMutation, UpdateMemberMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateMemberMutation, UpdateMemberMutationVariables>(UpdateMemberDocument, options)
}
export type UpdateMemberMutationHookResult = ReturnType<typeof useUpdateMemberMutation>
export type UpdateMemberMutationResult = Apollo.MutationResult<UpdateMemberMutation>
export type UpdateMemberMutationOptions = Apollo.BaseMutationOptions<
  UpdateMemberMutation,
  UpdateMemberMutationVariables
>
export const GetBlockSearchDocument = gql`
  query GetBlockSearch($domain: String!, $input: String!) {
    blockSearch(domain: $domain, input: $input) {
      id
      type
      text
      rootId
    }
  }
`

/**
 * __useGetBlockSearchQuery__
 *
 * To run a query within a React component, call `useGetBlockSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBlockSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBlockSearchQuery({
 *   variables: {
 *      domain: // value for 'domain'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGetBlockSearchQuery(
  baseOptions: Apollo.QueryHookOptions<GetBlockSearchQuery, GetBlockSearchQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBlockSearchQuery, GetBlockSearchQueryVariables>(GetBlockSearchDocument, options)
}
export function useGetBlockSearchLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetBlockSearchQuery, GetBlockSearchQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBlockSearchQuery, GetBlockSearchQueryVariables>(GetBlockSearchDocument, options)
}
export type GetBlockSearchQueryHookResult = ReturnType<typeof useGetBlockSearchQuery>
export type GetBlockSearchLazyQueryHookResult = ReturnType<typeof useGetBlockSearchLazyQuery>
export type GetBlockSearchQueryResult = Apollo.QueryResult<GetBlockSearchQuery, GetBlockSearchQueryVariables>
export const GetPageBlocksDocument = gql`
  query GetPageBlocks($domain: String!) {
    pageBlocks(domain: $domain) {
      id
      sort
      nextSort
      firstChildSort
      rootId
      parentId
      type
      text
      content
      data
      meta {
        cover {
          ... on BlockImage {
            type
            source
            key
          }
          ... on BlockColor {
            type
            color
          }
        }
        icon {
          ... on BlockImage {
            type
            source
            key
          }
          ... on BlockEmoji {
            type
            name
            emoji
          }
        }
      }
    }
  }
`

/**
 * __useGetPageBlocksQuery__
 *
 * To run a query within a React component, call `useGetPageBlocksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPageBlocksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPageBlocksQuery({
 *   variables: {
 *      domain: // value for 'domain'
 *   },
 * });
 */
export function useGetPageBlocksQuery(
  baseOptions: Apollo.QueryHookOptions<GetPageBlocksQuery, GetPageBlocksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPageBlocksQuery, GetPageBlocksQueryVariables>(GetPageBlocksDocument, options)
}
export function useGetPageBlocksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPageBlocksQuery, GetPageBlocksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPageBlocksQuery, GetPageBlocksQueryVariables>(GetPageBlocksDocument, options)
}
export type GetPageBlocksQueryHookResult = ReturnType<typeof useGetPageBlocksQuery>
export type GetPageBlocksLazyQueryHookResult = ReturnType<typeof useGetPageBlocksLazyQuery>
export type GetPageBlocksQueryResult = Apollo.QueryResult<GetPageBlocksQuery, GetPageBlocksQueryVariables>
export const GetTrashBlocksDocument = gql`
  query GetTrashBlocks($domain: String!, $blockId: UUID, $search: String) {
    trashBlocks(domain: $domain, blockId: $blockId, search: $search) {
      id
      deletedAt
      pathArray {
        id
        text
        icon {
          ... on BlockImage {
            type
            source
            key
          }
          ... on BlockEmoji {
            type
            name
            emoji
          }
        }
      }
      rootId
      parentId
      type
      text
      meta {
        people {
          type
          domain
          name
          avatarUrl
        }
        cover {
          ... on BlockImage {
            type
            source
            key
          }
          ... on BlockColor {
            type
            color
          }
        }
        icon {
          ... on BlockImage {
            type
            source
            key
          }
          ... on BlockEmoji {
            type
            name
            emoji
          }
        }
      }
    }
  }
`

/**
 * __useGetTrashBlocksQuery__
 *
 * To run a query within a React component, call `useGetTrashBlocksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTrashBlocksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTrashBlocksQuery({
 *   variables: {
 *      domain: // value for 'domain'
 *      blockId: // value for 'blockId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useGetTrashBlocksQuery(
  baseOptions: Apollo.QueryHookOptions<GetTrashBlocksQuery, GetTrashBlocksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetTrashBlocksQuery, GetTrashBlocksQueryVariables>(GetTrashBlocksDocument, options)
}
export function useGetTrashBlocksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetTrashBlocksQuery, GetTrashBlocksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetTrashBlocksQuery, GetTrashBlocksQueryVariables>(GetTrashBlocksDocument, options)
}
export type GetTrashBlocksQueryHookResult = ReturnType<typeof useGetTrashBlocksQuery>
export type GetTrashBlocksLazyQueryHookResult = ReturnType<typeof useGetTrashBlocksLazyQuery>
export type GetTrashBlocksQueryResult = Apollo.QueryResult<GetTrashBlocksQuery, GetTrashBlocksQueryVariables>
export const GetBlockShareLinksDocument = gql`
  query GetBlockShareLinks($id: String!) {
    blockShareLinks(id: $id) {
      key
      policy
      state
      sharePodData {
        name
        domain
        email
        avatarData {
          url
        }
      }
    }
  }
`

/**
 * __useGetBlockShareLinksQuery__
 *
 * To run a query within a React component, call `useGetBlockShareLinksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBlockShareLinksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBlockShareLinksQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBlockShareLinksQuery(
  baseOptions: Apollo.QueryHookOptions<GetBlockShareLinksQuery, GetBlockShareLinksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBlockShareLinksQuery, GetBlockShareLinksQueryVariables>(GetBlockShareLinksDocument, options)
}
export function useGetBlockShareLinksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetBlockShareLinksQuery, GetBlockShareLinksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBlockShareLinksQuery, GetBlockShareLinksQueryVariables>(
    GetBlockShareLinksDocument,
    options
  )
}
export type GetBlockShareLinksQueryHookResult = ReturnType<typeof useGetBlockShareLinksQuery>
export type GetBlockShareLinksLazyQueryHookResult = ReturnType<typeof useGetBlockShareLinksLazyQuery>
export type GetBlockShareLinksQueryResult = Apollo.QueryResult<
  GetBlockShareLinksQuery,
  GetBlockShareLinksQueryVariables
>
export const BlockDuplicateDocument = gql`
  mutation blockDuplicate($input: BlockDuplicateInput!) {
    blockDuplicate(input: $input) {
      id
      formulaIds
      errors
    }
  }
`
export type BlockDuplicateMutationFn = Apollo.MutationFunction<BlockDuplicateMutation, BlockDuplicateMutationVariables>

/**
 * __useBlockDuplicateMutation__
 *
 * To run a mutation, you first call `useBlockDuplicateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockDuplicateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockDuplicateMutation, { data, loading, error }] = useBlockDuplicateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockDuplicateMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockDuplicateMutation, BlockDuplicateMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockDuplicateMutation, BlockDuplicateMutationVariables>(BlockDuplicateDocument, options)
}
export type BlockDuplicateMutationHookResult = ReturnType<typeof useBlockDuplicateMutation>
export type BlockDuplicateMutationResult = Apollo.MutationResult<BlockDuplicateMutation>
export type BlockDuplicateMutationOptions = Apollo.BaseMutationOptions<
  BlockDuplicateMutation,
  BlockDuplicateMutationVariables
>
export const BlockSoftDeleteDocument = gql`
  mutation blockSoftDelete($input: BlockSoftDeleteInput!) {
    blockSoftDelete(input: $input) {
      errors
    }
  }
`
export type BlockSoftDeleteMutationFn = Apollo.MutationFunction<
  BlockSoftDeleteMutation,
  BlockSoftDeleteMutationVariables
>

/**
 * __useBlockSoftDeleteMutation__
 *
 * To run a mutation, you first call `useBlockSoftDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockSoftDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockSoftDeleteMutation, { data, loading, error }] = useBlockSoftDeleteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockSoftDeleteMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockSoftDeleteMutation, BlockSoftDeleteMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockSoftDeleteMutation, BlockSoftDeleteMutationVariables>(BlockSoftDeleteDocument, options)
}
export type BlockSoftDeleteMutationHookResult = ReturnType<typeof useBlockSoftDeleteMutation>
export type BlockSoftDeleteMutationResult = Apollo.MutationResult<BlockSoftDeleteMutation>
export type BlockSoftDeleteMutationOptions = Apollo.BaseMutationOptions<
  BlockSoftDeleteMutation,
  BlockSoftDeleteMutationVariables
>
export const BlockHardDeleteDocument = gql`
  mutation blockHardDelete($input: BlockHardDeleteInput!) {
    blockHardDelete(input: $input) {
      errors
    }
  }
`
export type BlockHardDeleteMutationFn = Apollo.MutationFunction<
  BlockHardDeleteMutation,
  BlockHardDeleteMutationVariables
>

/**
 * __useBlockHardDeleteMutation__
 *
 * To run a mutation, you first call `useBlockHardDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockHardDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockHardDeleteMutation, { data, loading, error }] = useBlockHardDeleteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockHardDeleteMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockHardDeleteMutation, BlockHardDeleteMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockHardDeleteMutation, BlockHardDeleteMutationVariables>(BlockHardDeleteDocument, options)
}
export type BlockHardDeleteMutationHookResult = ReturnType<typeof useBlockHardDeleteMutation>
export type BlockHardDeleteMutationResult = Apollo.MutationResult<BlockHardDeleteMutation>
export type BlockHardDeleteMutationOptions = Apollo.BaseMutationOptions<
  BlockHardDeleteMutation,
  BlockHardDeleteMutationVariables
>
export const BlockRestoreDocument = gql`
  mutation blockRestore($input: BlockRestoreInput!) {
    blockRestore(input: $input) {
      errors
    }
  }
`
export type BlockRestoreMutationFn = Apollo.MutationFunction<BlockRestoreMutation, BlockRestoreMutationVariables>

/**
 * __useBlockRestoreMutation__
 *
 * To run a mutation, you first call `useBlockRestoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockRestoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockRestoreMutation, { data, loading, error }] = useBlockRestoreMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockRestoreMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockRestoreMutation, BlockRestoreMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockRestoreMutation, BlockRestoreMutationVariables>(BlockRestoreDocument, options)
}
export type BlockRestoreMutationHookResult = ReturnType<typeof useBlockRestoreMutation>
export type BlockRestoreMutationResult = Apollo.MutationResult<BlockRestoreMutation>
export type BlockRestoreMutationOptions = Apollo.BaseMutationOptions<
  BlockRestoreMutation,
  BlockRestoreMutationVariables
>
export const BlockPinOrUnpinDocument = gql`
  mutation blockPinOrUnpin($input: BlockPinOrUnpinInput!) {
    blockPinOrUnpin(input: $input) {
      errors
    }
  }
`
export type BlockPinOrUnpinMutationFn = Apollo.MutationFunction<
  BlockPinOrUnpinMutation,
  BlockPinOrUnpinMutationVariables
>

/**
 * __useBlockPinOrUnpinMutation__
 *
 * To run a mutation, you first call `useBlockPinOrUnpinMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockPinOrUnpinMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockPinOrUnpinMutation, { data, loading, error }] = useBlockPinOrUnpinMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockPinOrUnpinMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockPinOrUnpinMutation, BlockPinOrUnpinMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockPinOrUnpinMutation, BlockPinOrUnpinMutationVariables>(BlockPinOrUnpinDocument, options)
}
export type BlockPinOrUnpinMutationHookResult = ReturnType<typeof useBlockPinOrUnpinMutation>
export type BlockPinOrUnpinMutationResult = Apollo.MutationResult<BlockPinOrUnpinMutation>
export type BlockPinOrUnpinMutationOptions = Apollo.BaseMutationOptions<
  BlockPinOrUnpinMutation,
  BlockPinOrUnpinMutationVariables
>
export const BlockCreateDocument = gql`
  mutation blockCreate($input: BlockCreateInput!) {
    blockCreate(input: $input) {
      id
      errors
    }
  }
`
export type BlockCreateMutationFn = Apollo.MutationFunction<BlockCreateMutation, BlockCreateMutationVariables>

/**
 * __useBlockCreateMutation__
 *
 * To run a mutation, you first call `useBlockCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockCreateMutation, { data, loading, error }] = useBlockCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockCreateMutation, BlockCreateMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockCreateMutation, BlockCreateMutationVariables>(BlockCreateDocument, options)
}
export type BlockCreateMutationHookResult = ReturnType<typeof useBlockCreateMutation>
export type BlockCreateMutationResult = Apollo.MutationResult<BlockCreateMutation>
export type BlockCreateMutationOptions = Apollo.BaseMutationOptions<BlockCreateMutation, BlockCreateMutationVariables>
export const BlockCreateShareLinkDocument = gql`
  mutation blockCreateShareLink($input: BlockCreateShareLinkInput!) {
    blockCreateShareLink(input: $input) {
      errors
    }
  }
`
export type BlockCreateShareLinkMutationFn = Apollo.MutationFunction<
  BlockCreateShareLinkMutation,
  BlockCreateShareLinkMutationVariables
>

/**
 * __useBlockCreateShareLinkMutation__
 *
 * To run a mutation, you first call `useBlockCreateShareLinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockCreateShareLinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockCreateShareLinkMutation, { data, loading, error }] = useBlockCreateShareLinkMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockCreateShareLinkMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockCreateShareLinkMutation, BlockCreateShareLinkMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockCreateShareLinkMutation, BlockCreateShareLinkMutationVariables>(
    BlockCreateShareLinkDocument,
    options
  )
}
export type BlockCreateShareLinkMutationHookResult = ReturnType<typeof useBlockCreateShareLinkMutation>
export type BlockCreateShareLinkMutationResult = Apollo.MutationResult<BlockCreateShareLinkMutation>
export type BlockCreateShareLinkMutationOptions = Apollo.BaseMutationOptions<
  BlockCreateShareLinkMutation,
  BlockCreateShareLinkMutationVariables
>
export const BlockMoveDocument = gql`
  mutation blockMove($input: BlockMoveInput!) {
    blockMove(input: $input) {
      errors
    }
  }
`
export type BlockMoveMutationFn = Apollo.MutationFunction<BlockMoveMutation, BlockMoveMutationVariables>

/**
 * __useBlockMoveMutation__
 *
 * To run a mutation, you first call `useBlockMoveMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockMoveMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockMoveMutation, { data, loading, error }] = useBlockMoveMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockMoveMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockMoveMutation, BlockMoveMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockMoveMutation, BlockMoveMutationVariables>(BlockMoveDocument, options)
}
export type BlockMoveMutationHookResult = ReturnType<typeof useBlockMoveMutation>
export type BlockMoveMutationResult = Apollo.MutationResult<BlockMoveMutation>
export type BlockMoveMutationOptions = Apollo.BaseMutationOptions<BlockMoveMutation, BlockMoveMutationVariables>
export const BlockRenameDocument = gql`
  mutation blockRename($input: BlockRenameInput!) {
    blockRename(input: $input) {
      errors
    }
  }
`
export type BlockRenameMutationFn = Apollo.MutationFunction<BlockRenameMutation, BlockRenameMutationVariables>

/**
 * __useBlockRenameMutation__
 *
 * To run a mutation, you first call `useBlockRenameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockRenameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockRenameMutation, { data, loading, error }] = useBlockRenameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockRenameMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockRenameMutation, BlockRenameMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockRenameMutation, BlockRenameMutationVariables>(BlockRenameDocument, options)
}
export type BlockRenameMutationHookResult = ReturnType<typeof useBlockRenameMutation>
export type BlockRenameMutationResult = Apollo.MutationResult<BlockRenameMutation>
export type BlockRenameMutationOptions = Apollo.BaseMutationOptions<BlockRenameMutation, BlockRenameMutationVariables>
export const BlockSyncBatchDocument = gql`
  mutation blockSyncBatch($input: BlockSyncBatchInput!) {
    blockSyncBatch(input: $input) {
      errors
    }
  }
`
export type BlockSyncBatchMutationFn = Apollo.MutationFunction<BlockSyncBatchMutation, BlockSyncBatchMutationVariables>

/**
 * __useBlockSyncBatchMutation__
 *
 * To run a mutation, you first call `useBlockSyncBatchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockSyncBatchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockSyncBatchMutation, { data, loading, error }] = useBlockSyncBatchMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockSyncBatchMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockSyncBatchMutation, BlockSyncBatchMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockSyncBatchMutation, BlockSyncBatchMutationVariables>(BlockSyncBatchDocument, options)
}
export type BlockSyncBatchMutationHookResult = ReturnType<typeof useBlockSyncBatchMutation>
export type BlockSyncBatchMutationResult = Apollo.MutationResult<BlockSyncBatchMutation>
export type BlockSyncBatchMutationOptions = Apollo.BaseMutationOptions<
  BlockSyncBatchMutation,
  BlockSyncBatchMutationVariables
>
export const FormulaCommitDocument = gql`
  mutation formulaCommit($input: FormulaCommitInput!) {
    formulaCommit(input: $input) {
      errors
    }
  }
`
export type FormulaCommitMutationFn = Apollo.MutationFunction<FormulaCommitMutation, FormulaCommitMutationVariables>

/**
 * __useFormulaCommitMutation__
 *
 * To run a mutation, you first call `useFormulaCommitMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFormulaCommitMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [formulaCommitMutation, { data, loading, error }] = useFormulaCommitMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFormulaCommitMutation(
  baseOptions?: Apollo.MutationHookOptions<FormulaCommitMutation, FormulaCommitMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<FormulaCommitMutation, FormulaCommitMutationVariables>(FormulaCommitDocument, options)
}
export type FormulaCommitMutationHookResult = ReturnType<typeof useFormulaCommitMutation>
export type FormulaCommitMutationResult = Apollo.MutationResult<FormulaCommitMutation>
export type FormulaCommitMutationOptions = Apollo.BaseMutationOptions<
  FormulaCommitMutation,
  FormulaCommitMutationVariables
>
export const ConversationCommentCreateDocument = gql`
  mutation conversationCommentCreate($input: ConversationCommentCreateInput!) {
    conversationCommentCreate(input: $input) {
      conversation {
        id
        docId
        markIds
        blockIds
        latestReplyAt
        updatedAt
        createdAt
        status
        comments {
          id
          content
          status
          createdAt
          updatedAt
          creator {
            name
            domain
            avatarData {
              url
              downloadUrl
              signedId
            }
          }
        }
      }
      errors
    }
  }
`
export type ConversationCommentCreateMutationFn = Apollo.MutationFunction<
  ConversationCommentCreateMutation,
  ConversationCommentCreateMutationVariables
>

/**
 * __useConversationCommentCreateMutation__
 *
 * To run a mutation, you first call `useConversationCommentCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConversationCommentCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [conversationCommentCreateMutation, { data, loading, error }] = useConversationCommentCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useConversationCommentCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ConversationCommentCreateMutation,
    ConversationCommentCreateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<ConversationCommentCreateMutation, ConversationCommentCreateMutationVariables>(
    ConversationCommentCreateDocument,
    options
  )
}
export type ConversationCommentCreateMutationHookResult = ReturnType<typeof useConversationCommentCreateMutation>
export type ConversationCommentCreateMutationResult = Apollo.MutationResult<ConversationCommentCreateMutation>
export type ConversationCommentCreateMutationOptions = Apollo.BaseMutationOptions<
  ConversationCommentCreateMutation,
  ConversationCommentCreateMutationVariables
>
export const ConversationCommentAppendDocument = gql`
  mutation conversationCommentAppend($input: ConversationCommentAppendInput!) {
    conversationCommentAppend(input: $input) {
      errors
      comment {
        id
        content
        status
        createdAt
        updatedAt
        creator {
          name
          domain
          avatarData {
            url
            downloadUrl
            signedId
          }
        }
      }
    }
  }
`
export type ConversationCommentAppendMutationFn = Apollo.MutationFunction<
  ConversationCommentAppendMutation,
  ConversationCommentAppendMutationVariables
>

/**
 * __useConversationCommentAppendMutation__
 *
 * To run a mutation, you first call `useConversationCommentAppendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConversationCommentAppendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [conversationCommentAppendMutation, { data, loading, error }] = useConversationCommentAppendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useConversationCommentAppendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ConversationCommentAppendMutation,
    ConversationCommentAppendMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<ConversationCommentAppendMutation, ConversationCommentAppendMutationVariables>(
    ConversationCommentAppendDocument,
    options
  )
}
export type ConversationCommentAppendMutationHookResult = ReturnType<typeof useConversationCommentAppendMutation>
export type ConversationCommentAppendMutationResult = Apollo.MutationResult<ConversationCommentAppendMutation>
export type ConversationCommentAppendMutationOptions = Apollo.BaseMutationOptions<
  ConversationCommentAppendMutation,
  ConversationCommentAppendMutationVariables
>
export const GetConversationCommentsDocument = gql`
  query GetConversationComments($pageIds: [UUID!]!) {
    conversationComments(pageIds: $pageIds) {
      id
      docId
      markIds
      blockIds
      latestReplyAt
      updatedAt
      createdAt
      status
      comments {
        id
        content
        status
        createdAt
        updatedAt
        creator {
          name
          domain
          avatarData {
            url
            downloadUrl
            signedId
          }
        }
      }
    }
  }
`

/**
 * __useGetConversationCommentsQuery__
 *
 * To run a query within a React component, call `useGetConversationCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetConversationCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetConversationCommentsQuery({
 *   variables: {
 *      pageIds: // value for 'pageIds'
 *   },
 * });
 */
export function useGetConversationCommentsQuery(
  baseOptions: Apollo.QueryHookOptions<GetConversationCommentsQuery, GetConversationCommentsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetConversationCommentsQuery, GetConversationCommentsQueryVariables>(
    GetConversationCommentsDocument,
    options
  )
}
export function useGetConversationCommentsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetConversationCommentsQuery, GetConversationCommentsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetConversationCommentsQuery, GetConversationCommentsQueryVariables>(
    GetConversationCommentsDocument,
    options
  )
}
export type GetConversationCommentsQueryHookResult = ReturnType<typeof useGetConversationCommentsQuery>
export type GetConversationCommentsLazyQueryHookResult = ReturnType<typeof useGetConversationCommentsLazyQuery>
export type GetConversationCommentsQueryResult = Apollo.QueryResult<
  GetConversationCommentsQuery,
  GetConversationCommentsQueryVariables
>
export const GetFormulasDocument = gql`
  query GetFormulas($domain: String!, $ids: String) {
    formulas(domain: $domain, ids: $ids) {
      id
      name
      cacheValue
      blockId
      definition
      updatedAt
      createdAt
      version
      type
      meta
    }
  }
`

/**
 * __useGetFormulasQuery__
 *
 * To run a query within a React component, call `useGetFormulasQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFormulasQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFormulasQuery({
 *   variables: {
 *      domain: // value for 'domain'
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useGetFormulasQuery(baseOptions: Apollo.QueryHookOptions<GetFormulasQuery, GetFormulasQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetFormulasQuery, GetFormulasQueryVariables>(GetFormulasDocument, options)
}
export function useGetFormulasLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetFormulasQuery, GetFormulasQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetFormulasQuery, GetFormulasQueryVariables>(GetFormulasDocument, options)
}
export type GetFormulasQueryHookResult = ReturnType<typeof useGetFormulasQuery>
export type GetFormulasLazyQueryHookResult = ReturnType<typeof useGetFormulasLazyQuery>
export type GetFormulasQueryResult = Apollo.QueryResult<GetFormulasQuery, GetFormulasQueryVariables>
export const NewPatchDocument = gql`
  subscription newPatch($docId: UUID!) {
    newPatch(docId: $docId) {
      state
      seq
      patches {
        id
        path
        patchType
        payload
        operatorId
      }
    }
  }
`

/**
 * __useNewPatchSubscription__
 *
 * To run a query within a React component, call `useNewPatchSubscription` and pass it any options that fit your needs.
 * When your component renders, `useNewPatchSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNewPatchSubscription({
 *   variables: {
 *      docId: // value for 'docId'
 *   },
 * });
 */
export function useNewPatchSubscription(
  baseOptions: Apollo.SubscriptionHookOptions<NewPatchSubscription, NewPatchSubscriptionVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<NewPatchSubscription, NewPatchSubscriptionVariables>(NewPatchDocument, options)
}
export type NewPatchSubscriptionHookResult = ReturnType<typeof useNewPatchSubscription>
export type NewPatchSubscriptionResult = Apollo.SubscriptionResult<NewPatchSubscription>
export const GetBlockInfoDocument = gql`
  query GetBlockInfo($id: String!, $domain: String!) {
    blockInfo(id: $id, domain: $domain) {
      title
      id
      enabledAlias {
        key
        payload
      }
      icon {
        ... on BlockImage {
          type
          source
          key
          height
          width
        }
        ... on BlockEmoji {
          type
          name
          emoji
        }
      }
      isDeleted
      isMaster
      pin
      pathArray {
        id
        text
        icon {
          ... on BlockImage {
            type
            source
            key
            height
            width
          }
          ... on BlockEmoji {
            type
            name
            emoji
          }
        }
      }
      permission {
        key
        policy
        state
      }
      collaborators {
        name
        domain
        email
        avatarData {
          url
        }
      }
    }
  }
`

/**
 * __useGetBlockInfoQuery__
 *
 * To run a query within a React component, call `useGetBlockInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBlockInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBlockInfoQuery({
 *   variables: {
 *      id: // value for 'id'
 *      domain: // value for 'domain'
 *   },
 * });
 */
export function useGetBlockInfoQuery(
  baseOptions: Apollo.QueryHookOptions<GetBlockInfoQuery, GetBlockInfoQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBlockInfoQuery, GetBlockInfoQueryVariables>(GetBlockInfoDocument, options)
}
export function useGetBlockInfoLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetBlockInfoQuery, GetBlockInfoQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBlockInfoQuery, GetBlockInfoQueryVariables>(GetBlockInfoDocument, options)
}
export type GetBlockInfoQueryHookResult = ReturnType<typeof useGetBlockInfoQuery>
export type GetBlockInfoLazyQueryHookResult = ReturnType<typeof useGetBlockInfoLazyQuery>
export type GetBlockInfoQueryResult = Apollo.QueryResult<GetBlockInfoQuery, GetBlockInfoQueryVariables>
export const GetChildrenBlocksDocument = gql`
  query GetChildrenBlocks($rootId: String!, $snapshotVersion: Int!) {
    childrenBlocks(rootId: $rootId, snapshotVersion: $snapshotVersion) {
      id
      sort
      parentId
      deletedAt
      rootId
      blobs {
        blobKey
        downloadUrl
        url
      }
      type
      text
      content
      data
      meta {
        title
        level
        language
        autoWrap
        start
        image {
          type
          source
          key
          viewUrl
          displayName
          height
          width
          ratio
          mode
          name
          size
          align
        }
        page {
          type
          key
          title
          icon
          link
        }
        people {
          type
          domain
          name
          avatarUrl
        }
        embedMeta {
          type
          embedType
        }
        attachment {
          type
          source
          key
          viewUrl
          height
          width
          name
          displayName
          size
          mode
        }
        cover {
          ... on BlockImage {
            type
            source
            key
            height
            width
          }
          ... on BlockColor {
            type
            color
          }
        }
        icon {
          ... on BlockImage {
            type
            source
            key
            height
            width
          }
          ... on BlockEmoji {
            type
            name
            emoji
          }
        }
        link {
          key
          type
          source
          cover
          description
          title
          displayName
          icon
          mode
        }
      }
    }
  }
`

/**
 * __useGetChildrenBlocksQuery__
 *
 * To run a query within a React component, call `useGetChildrenBlocksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChildrenBlocksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChildrenBlocksQuery({
 *   variables: {
 *      rootId: // value for 'rootId'
 *      snapshotVersion: // value for 'snapshotVersion'
 *   },
 * });
 */
export function useGetChildrenBlocksQuery(
  baseOptions: Apollo.QueryHookOptions<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>(GetChildrenBlocksDocument, options)
}
export function useGetChildrenBlocksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>(
    GetChildrenBlocksDocument,
    options
  )
}
export type GetChildrenBlocksQueryHookResult = ReturnType<typeof useGetChildrenBlocksQuery>
export type GetChildrenBlocksLazyQueryHookResult = ReturnType<typeof useGetChildrenBlocksLazyQuery>
export type GetChildrenBlocksQueryResult = Apollo.QueryResult<GetChildrenBlocksQuery, GetChildrenBlocksQueryVariables>
export const GetSpreadsheetChildrenDocument = gql`
  query GetSpreadsheetChildren($parentId: String!) {
    spreadsheetChildren(parentId: $parentId) {
      blocks {
        id
        sort
        parentId
        type
        text
        content
        data
      }
    }
  }
`

/**
 * __useGetSpreadsheetChildrenQuery__
 *
 * To run a query within a React component, call `useGetSpreadsheetChildrenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSpreadsheetChildrenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSpreadsheetChildrenQuery({
 *   variables: {
 *      parentId: // value for 'parentId'
 *   },
 * });
 */
export function useGetSpreadsheetChildrenQuery(
  baseOptions: Apollo.QueryHookOptions<GetSpreadsheetChildrenQuery, GetSpreadsheetChildrenQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetSpreadsheetChildrenQuery, GetSpreadsheetChildrenQueryVariables>(
    GetSpreadsheetChildrenDocument,
    options
  )
}
export function useGetSpreadsheetChildrenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetSpreadsheetChildrenQuery, GetSpreadsheetChildrenQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetSpreadsheetChildrenQuery, GetSpreadsheetChildrenQueryVariables>(
    GetSpreadsheetChildrenDocument,
    options
  )
}
export type GetSpreadsheetChildrenQueryHookResult = ReturnType<typeof useGetSpreadsheetChildrenQuery>
export type GetSpreadsheetChildrenLazyQueryHookResult = ReturnType<typeof useGetSpreadsheetChildrenLazyQuery>
export type GetSpreadsheetChildrenQueryResult = Apollo.QueryResult<
  GetSpreadsheetChildrenQuery,
  GetSpreadsheetChildrenQueryVariables
>
export const BlockNewDocument = gql`
  query BlockNew($id: String!, $historyId: String) {
    blockNew(id: $id, historyId: $historyId) {
      id
      statesCount
      stateId
      blockType
      states {
        id
        state
      }
    }
  }
`

/**
 * __useBlockNewQuery__
 *
 * To run a query within a React component, call `useBlockNewQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlockNewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlockNewQuery({
 *   variables: {
 *      id: // value for 'id'
 *      historyId: // value for 'historyId'
 *   },
 * });
 */
export function useBlockNewQuery(baseOptions: Apollo.QueryHookOptions<BlockNewQuery, BlockNewQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BlockNewQuery, BlockNewQueryVariables>(BlockNewDocument, options)
}
export function useBlockNewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlockNewQuery, BlockNewQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BlockNewQuery, BlockNewQueryVariables>(BlockNewDocument, options)
}
export type BlockNewQueryHookResult = ReturnType<typeof useBlockNewQuery>
export type BlockNewLazyQueryHookResult = ReturnType<typeof useBlockNewLazyQuery>
export type BlockNewQueryResult = Apollo.QueryResult<BlockNewQuery, BlockNewQueryVariables>
export const DocumentHistoriesDocument = gql`
  query documentHistories($id: String!) {
    documentHistories(id: $id) {
      users {
        name
      }
      histories {
        id
        createdAt
        username
      }
    }
  }
`

/**
 * __useDocumentHistoriesQuery__
 *
 * To run a query within a React component, call `useDocumentHistoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useDocumentHistoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDocumentHistoriesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDocumentHistoriesQuery(
  baseOptions: Apollo.QueryHookOptions<DocumentHistoriesQuery, DocumentHistoriesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<DocumentHistoriesQuery, DocumentHistoriesQueryVariables>(DocumentHistoriesDocument, options)
}
export function useDocumentHistoriesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<DocumentHistoriesQuery, DocumentHistoriesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<DocumentHistoriesQuery, DocumentHistoriesQueryVariables>(
    DocumentHistoriesDocument,
    options
  )
}
export type DocumentHistoriesQueryHookResult = ReturnType<typeof useDocumentHistoriesQuery>
export type DocumentHistoriesLazyQueryHookResult = ReturnType<typeof useDocumentHistoriesLazyQuery>
export type DocumentHistoriesQueryResult = Apollo.QueryResult<DocumentHistoriesQuery, DocumentHistoriesQueryVariables>
export const BlockCommitDocument = gql`
  mutation BlockCommit($input: BlockCommitInput!) {
    blockCommit(input: $input) {
      errors
      block {
        id
        statesCount
        stateId
        blockType
      }
      diffStates {
        id
        state
        createdAt
      }
      requireFull
    }
  }
`
export type BlockCommitMutationFn = Apollo.MutationFunction<BlockCommitMutation, BlockCommitMutationVariables>

/**
 * __useBlockCommitMutation__
 *
 * To run a mutation, you first call `useBlockCommitMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBlockCommitMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [blockCommitMutation, { data, loading, error }] = useBlockCommitMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBlockCommitMutation(
  baseOptions?: Apollo.MutationHookOptions<BlockCommitMutation, BlockCommitMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<BlockCommitMutation, BlockCommitMutationVariables>(BlockCommitDocument, options)
}
export type BlockCommitMutationHookResult = ReturnType<typeof useBlockCommitMutation>
export type BlockCommitMutationResult = Apollo.MutationResult<BlockCommitMutation>
export type BlockCommitMutationOptions = Apollo.BaseMutationOptions<BlockCommitMutation, BlockCommitMutationVariables>
export const DocumentDocument = gql`
  subscription Document($docId: UUID!) {
    document(docId: $docId) {
      operatorId
      blocks {
        id
        statesCount
        stateId
        blockType
      }
      states {
        id
        state
        createdAt
        blockId
      }
      histories {
        id
        createdAt
        username
      }
    }
  }
`

/**
 * __useDocumentSubscription__
 *
 * To run a query within a React component, call `useDocumentSubscription` and pass it any options that fit your needs.
 * When your component renders, `useDocumentSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDocumentSubscription({
 *   variables: {
 *      docId: // value for 'docId'
 *   },
 * });
 */
export function useDocumentSubscription(
  baseOptions: Apollo.SubscriptionHookOptions<DocumentSubscription, DocumentSubscriptionVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<DocumentSubscription, DocumentSubscriptionVariables>(DocumentDocument, options)
}
export type DocumentSubscriptionHookResult = ReturnType<typeof useDocumentSubscription>
export type DocumentSubscriptionResult = Apollo.SubscriptionResult<DocumentSubscription>
export const UpdateDomainDocument = gql`
  mutation updateDomain($input: UpdateDomainInput!) {
    updateDomain(input: $input) {
      errors
    }
  }
`
export type UpdateDomainMutationFn = Apollo.MutationFunction<UpdateDomainMutation, UpdateDomainMutationVariables>

/**
 * __useUpdateDomainMutation__
 *
 * To run a mutation, you first call `useUpdateDomainMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDomainMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDomainMutation, { data, loading, error }] = useUpdateDomainMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateDomainMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateDomainMutation, UpdateDomainMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateDomainMutation, UpdateDomainMutationVariables>(UpdateDomainDocument, options)
}
export type UpdateDomainMutationHookResult = ReturnType<typeof useUpdateDomainMutation>
export type UpdateDomainMutationResult = Apollo.MutationResult<UpdateDomainMutation>
export type UpdateDomainMutationOptions = Apollo.BaseMutationOptions<
  UpdateDomainMutation,
  UpdateDomainMutationVariables
>
export const UserAppearanceUpdateDocument = gql`
  mutation UserAppearanceUpdate($input: UserAppearanceUpdateInput!) {
    userAppearanceUpdate(input: $input) {
      errors
    }
  }
`
export type UserAppearanceUpdateMutationFn = Apollo.MutationFunction<
  UserAppearanceUpdateMutation,
  UserAppearanceUpdateMutationVariables
>

/**
 * __useUserAppearanceUpdateMutation__
 *
 * To run a mutation, you first call `useUserAppearanceUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserAppearanceUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userAppearanceUpdateMutation, { data, loading, error }] = useUserAppearanceUpdateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserAppearanceUpdateMutation(
  baseOptions?: Apollo.MutationHookOptions<UserAppearanceUpdateMutation, UserAppearanceUpdateMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserAppearanceUpdateMutation, UserAppearanceUpdateMutationVariables>(
    UserAppearanceUpdateDocument,
    options
  )
}
export type UserAppearanceUpdateMutationHookResult = ReturnType<typeof useUserAppearanceUpdateMutation>
export type UserAppearanceUpdateMutationResult = Apollo.MutationResult<UserAppearanceUpdateMutation>
export type UserAppearanceUpdateMutationOptions = Apollo.BaseMutationOptions<
  UserAppearanceUpdateMutation,
  UserAppearanceUpdateMutationVariables
>
export const UserDestroyDocument = gql`
  mutation UserDestroy($input: UserDestroyInput!) {
    userDestroy(input: $input) {
      errors
    }
  }
`
export type UserDestroyMutationFn = Apollo.MutationFunction<UserDestroyMutation, UserDestroyMutationVariables>

/**
 * __useUserDestroyMutation__
 *
 * To run a mutation, you first call `useUserDestroyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserDestroyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userDestroyMutation, { data, loading, error }] = useUserDestroyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserDestroyMutation(
  baseOptions?: Apollo.MutationHookOptions<UserDestroyMutation, UserDestroyMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserDestroyMutation, UserDestroyMutationVariables>(UserDestroyDocument, options)
}
export type UserDestroyMutationHookResult = ReturnType<typeof useUserDestroyMutation>
export type UserDestroyMutationResult = Apollo.MutationResult<UserDestroyMutation>
export type UserDestroyMutationOptions = Apollo.BaseMutationOptions<UserDestroyMutation, UserDestroyMutationVariables>
export const PodDestroyDocument = gql`
  mutation PodDestroy($input: PodDestroyInput!) {
    podDestroy(input: $input) {
      errors
    }
  }
`
export type PodDestroyMutationFn = Apollo.MutationFunction<PodDestroyMutation, PodDestroyMutationVariables>

/**
 * __usePodDestroyMutation__
 *
 * To run a mutation, you first call `usePodDestroyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePodDestroyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [podDestroyMutation, { data, loading, error }] = usePodDestroyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePodDestroyMutation(
  baseOptions?: Apollo.MutationHookOptions<PodDestroyMutation, PodDestroyMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<PodDestroyMutation, PodDestroyMutationVariables>(PodDestroyDocument, options)
}
export type PodDestroyMutationHookResult = ReturnType<typeof usePodDestroyMutation>
export type PodDestroyMutationResult = Apollo.MutationResult<PodDestroyMutation>
export type PodDestroyMutationOptions = Apollo.BaseMutationOptions<PodDestroyMutation, PodDestroyMutationVariables>
export const PodLeaveDocument = gql`
  mutation PodLeave($input: PodLeaveInput!) {
    podLeave(input: $input) {
      errors
    }
  }
`
export type PodLeaveMutationFn = Apollo.MutationFunction<PodLeaveMutation, PodLeaveMutationVariables>

/**
 * __usePodLeaveMutation__
 *
 * To run a mutation, you first call `usePodLeaveMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePodLeaveMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [podLeaveMutation, { data, loading, error }] = usePodLeaveMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePodLeaveMutation(
  baseOptions?: Apollo.MutationHookOptions<PodLeaveMutation, PodLeaveMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<PodLeaveMutation, PodLeaveMutationVariables>(PodLeaveDocument, options)
}
export type PodLeaveMutationHookResult = ReturnType<typeof usePodLeaveMutation>
export type PodLeaveMutationResult = Apollo.MutationResult<PodLeaveMutation>
export type PodLeaveMutationOptions = Apollo.BaseMutationOptions<PodLeaveMutation, PodLeaveMutationVariables>
