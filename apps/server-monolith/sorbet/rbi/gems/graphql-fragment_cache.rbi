# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/graphql-fragment_cache/all/graphql-fragment_cache.rbi
#
# graphql-fragment_cache-1.11.0

module GraphQL
end
module GraphQL::FragmentCache
  def self.cache_store; end
  def self.cache_store=(store); end
  def self.configure; end
  def self.default_options; end
  def self.default_options=(arg0); end
  def self.graphql_ruby_before_2_0?; end
  def self.namespace; end
  def self.namespace=(arg0); end
  def self.use(schema_defn, options = nil); end
  def self.verify_interpreter_and_analysis!(schema_defn); end
end
module GraphQL::FragmentCache::Ext
end
class GraphQL::FragmentCache::CacheKeyBuilder
  def build; end
  def implicit_cache_key; end
  def initialize(query:, path:, object: nil, **options); end
  def object; end
  def object_cache_key; end
  def object_key(obj); end
  def path; end
  def path_cache_key; end
  def query; end
  def query_cache_key; end
  def schema; end
  def schema_cache_key; end
  def selections_cache_key; end
  def self.call(**options); end
  def traverse_argument(argument); end
end
class GraphQL::FragmentCache::Fragment
  def cache_key; end
  def context; end
  def final_value; end
  def initialize(context, **options); end
  def interpreter_context; end
  def options; end
  def path; end
  def read(keep_in_context = nil); end
  def read_from_context; end
  def value; end
  def value_from_cache; end
  def with_final_value?; end
end
module GraphQL::FragmentCache::ObjectHelpers
  def cache_fragment(object_to_cache = nil, **options, &block); end
  def self.included(base); end
  extend Forwardable
end
class GraphQL::FragmentCache::FieldExtension < GraphQL::Schema::FieldExtension
  def initialize(options:, **_rest); end
  def resolve(object:, arguments:, **_options); end
end
module GraphQL::FragmentCache::FieldExtension::Patch
  def build_extension(options); end
  def initialize(*args, **kwargs, &block); end
end
module GraphQL::FragmentCache::Object
  def self.included(base); end
end
module GraphQL::FragmentCache::Connections
end
module GraphQL::FragmentCache::Connections::Patch
  def raw_value?(value); end
end
module GraphQL::FragmentCache::Schema
end
module GraphQL::FragmentCache::Schema::Patch
  def schema_cache_key; end
end
class GraphQL::FragmentCache::Schema::Tracer
  def self.connection_field?(key, data); end
  def self.trace(key, data); end
  def self.verify_connections!(context); end
end
module GraphQL::FragmentCache::Cacher
  def self.batched_persist(query); end
  def self.call(query); end
  def self.persist(query); end
  def self.select_valid_fragments(query); end
end
module GraphQL::FragmentCache::Schema::Instrumentation
  def after_query(query); end
  def before_query(query); end
  def self.after_query(query); end
  def self.before_query(query); end
end
class GraphQL::FragmentCache::MemoryStore
  def clear; end
  def default_expires_in; end
  def delete(key); end
  def exist?(key); end
  def initialize(expires_in: nil, **other); end
  def keys; end
  def read(key); end
  def storage; end
  def write(key, value, expires_in: nil, **options); end
end
class Anonymous_Struct_44 < Struct
  def expires_at; end
  def expires_at=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def value; end
  def value=(_); end
end
class GraphQL::FragmentCache::MemoryStore::Entry < Anonymous_Struct_44
  def expired?; end
end
class GraphQL::FragmentCache::Railtie < Rails::Railtie
end
module GraphQL::FragmentCache::Railtie::Config
  def self.store=(store); end
end
