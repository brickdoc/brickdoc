#!/usr/bin/env node
/**
 * @file Generate routes definitions for react-router from the `routes` dir.
 */
import { globbySync } from 'globby'
import { pascalCase } from 'change-case'
import * as path from 'node:path'
import * as fs from 'node:fs'

const srcDir = path.resolve(path.dirname(new URL(import.meta.url).pathname), '../src')

const files = globbySync('**/*.@(ts|tsx)', {
  cwd: path.resolve(srcDir, './routes'),
  ignore: ['**/_shared', '**/*.style.@(ts|tsx)']
})

const routes = []
const result = Symbol('result')
const level = { [result]: routes }
files.forEach(file => {
  file.split('/').reduce((r, name, i, a) => {
    if (!r[name]) {
      r[name] = { [result]: [] }
      r[result].push({
        fileName: name,
        children: r[name][result]
      })
    }

    return r[name]
  }, level)
})

let imports = ''
const renderedRoutes = mapRoute({ children: routes, layoutRoute: {} }, '', '', 4)

fs.writeFileSync(
  path.resolve(srcDir, 'core/RootRoutes.tsx'),
  `// Auto generated by bin/generate-routes.mjs, DO NOT change this file manually!
import { FC, lazy } from 'react'
import { BrowserRouter, Route, Routes } from 'react-router-dom'

${imports}
export const RootRoutes: FC = () => {
  return (
    <BrowserRouter>
      <Routes>
${renderedRoutes}
      </Routes>
    </BrowserRouter>
  )
}
`
)

function mapRoute(root, importPrefix, pathPrefix, depth) {
  const children = root.children.map(route => {
    const isDir = route.children.length > 0
    const basename = isDir ? route.fileName : path.basename(route.fileName, path.extname(route.fileName))
    const routePath = basename === '$' ? '*' : basename.replaceAll('$', ':').replaceAll('.', '/')
    return {
      children: route.children,
      routePath,
      importPath: `${importPrefix}/${basename}`,
      fullRoutePath: `${pathPrefix}${routePath === 'index' ? '' : `${routePath}/`}`,
      componentName: pascalCase(
        // eslint-disable-next-line no-nested-ternary
        `${importPrefix}/${routePath === '*' ? 'match-all' : routePath === '_' ? 'layout' : routePath}`
      )
    }
  })
  const layoutChildIndex = children.findIndex(route => route.routePath === '_')
  if (layoutChildIndex > -1) {
    const [layoutRoute] = children.splice(layoutChildIndex, 1)
    root.layoutRoute = layoutRoute
    imports += `const ${layoutRoute.componentName} = lazy(async () => await import('../routes${layoutRoute.importPath}'))\n`
    // eslint-disable-next-line no-param-reassign
    depth += 1
  }
  return children
    .map(route => {
      const { routePath, importPath, fullRoutePath, componentName } = route
      let pathSegment = `path="${fullRoutePath.replace(/\/$/, '')}"`
      if (root.layoutRoute) {
        pathSegment = routePath === 'index' ? 'index' : `path="${routePath}"`
      }
      if (route.children.length === 0) {
        imports += `const ${componentName} = lazy(async () => await import('../routes${importPath}'))\n`
        return `${' '.repeat(depth * 2)}<Route ${pathSegment} element={<${componentName} />} />`
      } else {
        const childRoutes = mapRoute(route, importPath, root.layoutRoute ? `${routePath}/` : fullRoutePath, depth)
        if (route.layoutRoute) {
          return `${' '.repeat(depth * 2)}<Route ${pathSegment} element={<${
            route.layoutRoute.componentName
          } />}>\n${childRoutes}\n${' '.repeat(depth * 2)}</Route>`
        } else {
          return childRoutes
        }
      }
    })
    .filter(Boolean)
    .join('\n')
}
