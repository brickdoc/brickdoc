use argon2::{
  password_hash::{PasswordHasher, PasswordVerifier, SaltString},
  Algorithm, Argon2, Params, ParamsBuilder, Version,
};
use napi::bindgen_prelude::*;
use napi_derive::napi;
use rand_chacha::rand_core::SeedableRng;
/**
 * Part of the code from the https://github.com/napi-rs/node-rs/blob/main/packages/argon2/src/lib.rs
 * Copyright (c) 2020 LongYinan | MIT Licensed
 */

/// NOTES:
/// Argon2id should use one of the following configuration settings as a base
/// minimum which includes the minimum memory size (m), the minimum number of
///  iterations (ops) and the degree of parallelism (p).
/// m=37 MiB, ops=1, p=1
/// m=15 MiB, ops=2, p=1
/// Both of these configuration settings are equivalent in the defense they provide.
/// The only difference is a trade off between CPU and RAM usage
/// see  https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#argon2id
fn fixed_params() -> Params {
  let mut builder = ParamsBuilder::default();
  builder.m_cost(15000).unwrap(); // 15 MiB
  builder.t_cost(2).unwrap();
  builder.params().unwrap()
}

fn argon2id() -> Argon2<'static> {
  Argon2::new(Algorithm::Argon2id, Version::V0x13, fixed_params())
}

pub struct HashTask {
  password: Vec<u8>,
}

#[napi]
impl Task for HashTask {
  type Output = String;
  type JsValue = String;

  fn compute(&mut self) -> Result<Self::Output> {
    let rng = rand_chacha::ChaCha8Rng::from_entropy();
    let salt = SaltString::generate(rng);
    let hasher = Argon2::default();
    hasher
      .hash_password(self.password.as_slice(), &salt)
      .map_err(|err| Error::new(Status::GenericFailure, err.to_string()))
      .map(|h| h.to_string())
  }

  fn resolve(&mut self, _env: Env, output: Self::Output) -> Result<Self::JsValue> {
    Ok(output)
  }
}

/// Generate a password hash and salt using Argon2id.
/// @param password - password string to hash
/// @returns password hash
#[napi]
pub fn password_hash(password: String, abort_signal: Option<AbortSignal>) -> AsyncTask<HashTask> {
  AsyncTask::with_optional_signal(
    HashTask {
      password: password.as_bytes().to_vec(),
    },
    abort_signal,
  )
}

pub struct VerifyTask {
  password: String,
  hashed: String,
}

#[napi]
impl Task for VerifyTask {
  type Output = bool;
  type JsValue = bool;

  fn compute(&mut self) -> Result<Self::Output> {
    let parsed_hash = argon2::PasswordHash::new(self.hashed.as_str())
      .map_err(|err| Error::new(Status::InvalidArg, err.to_string()))?;
    let hasher = argon2id();
    Ok(
      hasher
        .verify_password(self.password.as_bytes(), &parsed_hash)
        .is_ok(),
    )
  }

  fn resolve(&mut self, _env: Env, output: Self::Output) -> Result<Self::JsValue> {
    Ok(output)
  }
}

/// Verifies a password hash generated by `passwordHash()`
/// @param hashed - password hash
/// @param password - password string to verify
/// @returns true if the password is correct
#[napi]
pub fn password_hash_verify(
  hashed: String,
  password: String,
  abort_signal: Option<AbortSignal>,
) -> Result<AsyncTask<VerifyTask>> {
  Ok(AsyncTask::with_optional_signal(
    VerifyTask { password, hashed },
    abort_signal,
  ))
}
