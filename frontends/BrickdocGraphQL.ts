import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
const defaultOptions = {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** Email Address */
  Email: any
  /** A valid http/https url or image uri */
  HttpUrl: any
}

/** Available authentication authentication. */
export enum AuthMethod {
  /** Email and Password Authentication */
  EmailPassword = 'email_password',
  /** Github Federated Authentication */
  Github = 'github'
}

/** page blocks */
export type PageBlock = {
  __typename?: 'PageBlock'
  /** children block ids */
  children?: Maybe<Array<Scalars['Int']>>
  /** children block */
  childrenBlocks?: Maybe<Array<Block>>
  /** collaborators */
  collaborators?: Maybe<Array<Accounts_User>>
  data: PageBlockData
  id: Scalars['ID']
  meta: PageBlockMeta
  /** parent uuid */
  parentId?: Maybe<Scalars['String']>
  /** parent type */
  parentType?: Maybe<Scalars['String']>
  /** block type */
  type: Scalars['String']
}

export type PageBlockData = {
  __typename?: 'PageBlockData'
  /** page title */
  title: Scalars['String']
}

export type PageBlockMeta = {
  __typename?: 'PageBlockMeta'
  /** cover image */
  cover?: Maybe<Scalars['HttpUrl']>
  /** page icon */
  icon?: Maybe<Scalars['String']>
}

export type RootMutation = {
  __typename?: 'RootMutation'
  /** Required `context[:entrypoints]` is `[:internal]`. */
  userConfirmationEmailResend?: Maybe<UserConfirmationEmailResendPayload>
  /** Required `context[:entrypoints]` is `[:internal]`. */
  userCreate?: Maybe<UserCreatePayload>
  /** Required `context[:entrypoints]` is `[:internal]`. */
  userEmailPasswordSignIn?: Maybe<UserEmailPasswordSignInPayload>
  /** Required `context[:entrypoints]` is `[:internal]`. */
  userForgetPasswordMailSend?: Maybe<UserForgetPasswordMailSendPayload>
  /** Required `context[:entrypoints]` is `[:internal]`. */
  userPasswordReset?: Maybe<UserPasswordResetPayload>
  /** Required `context[:entrypoints]` is `[:internal]`. */
  userSignOut?: Maybe<UserSignOutPayload>
}

export type RootMutationUserConfirmationEmailResendArgs = {
  input: UserConfirmationEmailResendInput
}

export type RootMutationUserCreateArgs = {
  input: UserCreateInput
}

export type RootMutationUserEmailPasswordSignInArgs = {
  input: UserEmailPasswordSignInInput
}

export type RootMutationUserForgetPasswordMailSendArgs = {
  input: UserForgetPasswordMailSendInput
}

export type RootMutationUserPasswordResetArgs = {
  input: UserPasswordResetInput
}

export type RootMutationUserSignOutArgs = {
  input: UserSignOutInput
}

export type RootQuery = {
  __typename?: 'RootQuery'
  /** return single block by id. */
  block?: Maybe<Block>
  blocks?: Maybe<Array<Block>>
  /**
   * provides a federated identity session data
   * Required `context[:entrypoints]` is `[:internal]`.
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  federatedIdentitySession: OmniauthSession
  /** Return information about current Brickdoc server instance. */
  metadata: Metadata
  /** return all pods for user. */
  pods: Array<Pod>
  /**
   * Check webid available.
   * Required `context[:entrypoints]` is `[:internal]`.
   * Required `context[:entrypoints]` is `[:internal]`.
   */
  webidAvailable: Scalars['Boolean']
}

export type RootQueryBlockArgs = {
  id: Scalars['String']
}

export type RootQueryBlocksArgs = {
  webid?: Maybe<Scalars['String']>
  parentId?: Maybe<Scalars['String']>
  onlyPage?: Maybe<Scalars['Boolean']>
  recursion?: Maybe<Scalars['Boolean']>
}

export type RootQueryWebidAvailableArgs = {
  webid: Scalars['String']
}

/** text blocks */
export type TextBlock = {
  __typename?: 'TextBlock'
  /** children block ids */
  children?: Maybe<Array<Scalars['Int']>>
  /** children block */
  childrenBlocks?: Maybe<Array<Block>>
  /** collaborators */
  collaborators?: Maybe<Array<Accounts_User>>
  data: TextBlockData
  id: Scalars['ID']
  /** parent uuid */
  parentId?: Maybe<Scalars['String']>
  /** parent type */
  parentType?: Maybe<Scalars['String']>
  /** block type */
  type: Scalars['String']
}

export type TextBlockData = {
  __typename?: 'TextBlockData'
  /** Text Content */
  content: Scalars['String']
}

/** Autogenerated input type of UserConfirmationEmailResend */
export type UserConfirmationEmailResendInput = {
  /** User's email address */
  email: Scalars['Email']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserConfirmationEmailResend */
export type UserConfirmationEmailResendPayload = {
  __typename?: 'UserConfirmationEmailResendPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of UserCreate */
export type UserCreateInput = {
  /** Like a username, Unique within this instance of Brickdoc. */
  webid: Scalars['String']
  /** Human-readable name of the user */
  name: Scalars['String']
  /** User's email address */
  email?: Maybe<Scalars['Email']>
  /** user password */
  password?: Maybe<Scalars['String']>
  /** User's preferred language */
  locale: Scalars['String']
  /** User's preferred timezone */
  timezone: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserCreate */
export type UserCreatePayload = {
  __typename?: 'UserCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  isUserActive?: Maybe<Scalars['Boolean']>
  /** redirect url path when sig up successful */
  redirectPath?: Maybe<Scalars['String']>
}

/** Autogenerated input type of UserEmailPasswordSignIn */
export type UserEmailPasswordSignInInput = {
  /** User's email address */
  email: Scalars['Email']
  /** user password */
  password: Scalars['String']
  /** remember authentication session */
  remember: Scalars['Boolean']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserEmailPasswordSignIn */
export type UserEmailPasswordSignInPayload = {
  __typename?: 'UserEmailPasswordSignInPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
  /** redirect url path when sign in successful */
  redirectPath?: Maybe<Scalars['String']>
}

/** Autogenerated input type of UserForgetPasswordMailSend */
export type UserForgetPasswordMailSendInput = {
  /** User's email address */
  email: Scalars['Email']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserForgetPasswordMailSend */
export type UserForgetPasswordMailSendPayload = {
  __typename?: 'UserForgetPasswordMailSendPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of UserPasswordReset */
export type UserPasswordResetInput = {
  /** Reset password token by Devise */
  token: Scalars['String']
  /** Reset password */
  password: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserPasswordReset */
export type UserPasswordResetPayload = {
  __typename?: 'UserPasswordResetPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** Autogenerated input type of UserSignOut */
export type UserSignOutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UserSignOut */
export type UserSignOutPayload = {
  __typename?: 'UserSignOutPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>
}

/** A user is an individual's accounts on Brickdoc can make new content. */
export type Accounts_User = {
  __typename?: 'accounts_user'
  /** the user's public profile bio */
  bio?: Maybe<Scalars['String']>
  /** User's email address */
  email?: Maybe<Scalars['String']>
  id: Scalars['ID']
  /** User's preferred language */
  locale: Scalars['String']
  /** Human-readable name of the user */
  name: Scalars['String']
  /** User's preferred timezone */
  timezone: Scalars['String']
  /** Like a username, Unique within this instance of Brickdoc. */
  webid: Scalars['String']
}

/** Brickdoc Docs::Block */
export type Block = PageBlock | TextBlock

/** Brickdoc Global Configuration */
export type Config = {
  __typename?: 'config'
  /** Enable email and password authentication */
  accountsEmailPasswordAuth: Scalars['Boolean']
  /** Enabled federated identity providers */
  accountsFederatedProviders: Array<FederatedProvider>
  /** Preferred Authentication authentication */
  accountsPreferredAuthMethod: AuthMethod
  /** User agreement link */
  userAgreementLink: Scalars['HttpUrl']
}

/** Accounts Federated Identity Provide Configuration */
export type FederatedProvider = {
  __typename?: 'federatedProvider'
  /** Provider Logo URI */
  logo: Scalars['HttpUrl']
  /** Provider Name */
  name: Scalars['String']
}

/** Represents information about the Brickdoc Server Instance. */
export type Metadata = {
  __typename?: 'metadata'
  /** Current available locales. */
  availableLocales: Array<Select_Option>
  /** Brickdoc Global Config */
  config: Config
  id: Scalars['ID']
}

/** session[:omniauth] */
export type OmniauthSession = {
  __typename?: 'omniauthSession'
  hasSession: Scalars['Boolean']
  /** Human-readable name of the user */
  name?: Maybe<Scalars['String']>
  /** Provider Name */
  provider?: Maybe<Scalars['String']>
  /** Like a username, Unique within this instance of Brickdoc. */
  webid?: Maybe<Scalars['String']>
}

/** Brickdoc Pod. */
export type Pod = {
  __typename?: 'pod'
  /** Pod Avatar */
  avatar?: Maybe<Scalars['String']>
  /** public profile bio */
  bio?: Maybe<Scalars['String']>
  id: Scalars['ID']
  /** Pod Name */
  name?: Maybe<Scalars['String']>
  /** Like a username, Unique within this instance of Brickdoc */
  webid: Scalars['String']
}

/** Option Object for BrickDesign Select Component. */
export type Select_Option = {
  __typename?: 'select_option'
  /** option label */
  label: Scalars['String']
  /** option value */
  value: Scalars['String']
}

export type UserSignOutMutationVariables = Exact<{
  input: UserSignOutInput
}>

export type UserSignOutMutation = { __typename?: 'RootMutation' } & {
  userSignOut?: Maybe<{ __typename?: 'UserSignOutPayload' } & Pick<UserSignOutPayload, 'errors'>>
}

export type GetAccountsConfigFromWsQueryVariables = Exact<{ [key: string]: never }>

export type GetAccountsConfigFromWsQuery = { __typename?: 'RootQuery' } & {
  metadata: { __typename?: 'metadata' } & Pick<Metadata, 'id'> & {
      config: { __typename?: 'config' } & Pick<
        Config,
        'userAgreementLink' | 'accountsPreferredAuthMethod' | 'accountsEmailPasswordAuth'
      > & { accountsFederatedProviders: Array<{ __typename?: 'federatedProvider' } & Pick<FederatedProvider, 'name' | 'logo'>> }
    }
}

export type UserForgetPasswordMailSendMutationVariables = Exact<{
  input: UserForgetPasswordMailSendInput
}>

export type UserForgetPasswordMailSendMutation = { __typename?: 'RootMutation' } & {
  userForgetPasswordMailSend?: Maybe<
    { __typename?: 'UserForgetPasswordMailSendPayload' } & Pick<UserForgetPasswordMailSendPayload, 'errors'>
  >
}

export type UserPasswordResetMutationVariables = Exact<{
  input: UserPasswordResetInput
}>

export type UserPasswordResetMutation = { __typename?: 'RootMutation' } & {
  userPasswordReset?: Maybe<{ __typename?: 'UserPasswordResetPayload' } & Pick<UserPasswordResetPayload, 'errors'>>
}

export type UserEmailPasswordSignInMutationVariables = Exact<{
  input: UserEmailPasswordSignInInput
}>

export type UserEmailPasswordSignInMutation = { __typename?: 'RootMutation' } & {
  userEmailPasswordSignIn?: Maybe<
    { __typename?: 'UserEmailPasswordSignInPayload' } & Pick<UserEmailPasswordSignInPayload, 'errors' | 'redirectPath'>
  >
}

export type GetFederatedIdentitySessionQueryVariables = Exact<{ [key: string]: never }>

export type GetFederatedIdentitySessionQuery = { __typename?: 'RootQuery' } & {
  federatedIdentitySession: { __typename?: 'omniauthSession' } & Pick<OmniauthSession, 'hasSession' | 'webid' | 'name' | 'provider'>
}

export type UserCreateMutationVariables = Exact<{
  input: UserCreateInput
}>

export type UserCreateMutation = { __typename?: 'RootMutation' } & {
  userCreate?: Maybe<{ __typename?: 'UserCreatePayload' } & Pick<UserCreatePayload, 'errors' | 'redirectPath' | 'isUserActive'>>
}

export type UserConfirmationEmailResendMutationVariables = Exact<{
  input: UserConfirmationEmailResendInput
}>

export type UserConfirmationEmailResendMutation = { __typename?: 'RootMutation' } & {
  userConfirmationEmailResend?: Maybe<
    { __typename?: 'UserConfirmationEmailResendPayload' } & Pick<UserConfirmationEmailResendPayload, 'errors'>
  >
}

export type QueryWebidAvailableFromWsQueryVariables = Exact<{
  webid: Scalars['String']
}>

export type QueryWebidAvailableFromWsQuery = { __typename?: 'RootQuery' } & Pick<RootQuery, 'webidAvailable'>

export type GetAvailableLocalesFromWsQueryVariables = Exact<{ [key: string]: never }>

export type GetAvailableLocalesFromWsQuery = { __typename?: 'RootQuery' } & {
  metadata: { __typename?: 'metadata' } & Pick<Metadata, 'id'> & {
      availableLocales: Array<{ __typename?: 'select_option' } & Pick<Select_Option, 'label' | 'value'>>
    }
}

export type GetPodsQueryVariables = Exact<{ [key: string]: never }>

export type GetPodsQuery = { __typename?: 'RootQuery' } & { pods: Array<{ __typename?: 'pod' } & Pick<Pod, 'webid' | 'name' | 'avatar'>> }

export const UserSignOutDocument = gql`
  mutation userSignOut($input: UserSignOutInput!) {
    userSignOut(input: $input) {
      errors
    }
  }
`
export type UserSignOutMutationFn = Apollo.MutationFunction<UserSignOutMutation, UserSignOutMutationVariables>

/**
 * __useUserSignOutMutation__
 *
 * To run a mutation, you first call `useUserSignOutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserSignOutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userSignOutMutation, { data, loading, error }] = useUserSignOutMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserSignOutMutation(baseOptions?: Apollo.MutationHookOptions<UserSignOutMutation, UserSignOutMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserSignOutMutation, UserSignOutMutationVariables>(UserSignOutDocument, options)
}
export type UserSignOutMutationHookResult = ReturnType<typeof useUserSignOutMutation>
export type UserSignOutMutationResult = Apollo.MutationResult<UserSignOutMutation>
export type UserSignOutMutationOptions = Apollo.BaseMutationOptions<UserSignOutMutation, UserSignOutMutationVariables>
export const GetAccountsConfigFromWsDocument = gql`
  query GetAccountsConfigFromWS {
    metadata {
      id
      config {
        userAgreementLink
        accountsPreferredAuthMethod
        accountsEmailPasswordAuth
        accountsFederatedProviders {
          name
          logo
        }
      }
    }
  }
`

/**
 * __useGetAccountsConfigFromWsQuery__
 *
 * To run a query within a React component, call `useGetAccountsConfigFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAccountsConfigFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAccountsConfigFromWsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAccountsConfigFromWsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>(GetAccountsConfigFromWsDocument, options)
}
export function useGetAccountsConfigFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>(GetAccountsConfigFromWsDocument, options)
}
export type GetAccountsConfigFromWsQueryHookResult = ReturnType<typeof useGetAccountsConfigFromWsQuery>
export type GetAccountsConfigFromWsLazyQueryHookResult = ReturnType<typeof useGetAccountsConfigFromWsLazyQuery>
export type GetAccountsConfigFromWsQueryResult = Apollo.QueryResult<GetAccountsConfigFromWsQuery, GetAccountsConfigFromWsQueryVariables>
export const UserForgetPasswordMailSendDocument = gql`
  mutation userForgetPasswordMailSend($input: UserForgetPasswordMailSendInput!) {
    userForgetPasswordMailSend(input: $input) {
      errors
    }
  }
`
export type UserForgetPasswordMailSendMutationFn = Apollo.MutationFunction<
  UserForgetPasswordMailSendMutation,
  UserForgetPasswordMailSendMutationVariables
>

/**
 * __useUserForgetPasswordMailSendMutation__
 *
 * To run a mutation, you first call `useUserForgetPasswordMailSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserForgetPasswordMailSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userForgetPasswordMailSendMutation, { data, loading, error }] = useUserForgetPasswordMailSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserForgetPasswordMailSendMutation(
  baseOptions?: Apollo.MutationHookOptions<UserForgetPasswordMailSendMutation, UserForgetPasswordMailSendMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserForgetPasswordMailSendMutation, UserForgetPasswordMailSendMutationVariables>(
    UserForgetPasswordMailSendDocument,
    options
  )
}
export type UserForgetPasswordMailSendMutationHookResult = ReturnType<typeof useUserForgetPasswordMailSendMutation>
export type UserForgetPasswordMailSendMutationResult = Apollo.MutationResult<UserForgetPasswordMailSendMutation>
export type UserForgetPasswordMailSendMutationOptions = Apollo.BaseMutationOptions<
  UserForgetPasswordMailSendMutation,
  UserForgetPasswordMailSendMutationVariables
>
export const UserPasswordResetDocument = gql`
  mutation userPasswordReset($input: UserPasswordResetInput!) {
    userPasswordReset(input: $input) {
      errors
    }
  }
`
export type UserPasswordResetMutationFn = Apollo.MutationFunction<UserPasswordResetMutation, UserPasswordResetMutationVariables>

/**
 * __useUserPasswordResetMutation__
 *
 * To run a mutation, you first call `useUserPasswordResetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPasswordResetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPasswordResetMutation, { data, loading, error }] = useUserPasswordResetMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserPasswordResetMutation(
  baseOptions?: Apollo.MutationHookOptions<UserPasswordResetMutation, UserPasswordResetMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserPasswordResetMutation, UserPasswordResetMutationVariables>(UserPasswordResetDocument, options)
}
export type UserPasswordResetMutationHookResult = ReturnType<typeof useUserPasswordResetMutation>
export type UserPasswordResetMutationResult = Apollo.MutationResult<UserPasswordResetMutation>
export type UserPasswordResetMutationOptions = Apollo.BaseMutationOptions<UserPasswordResetMutation, UserPasswordResetMutationVariables>
export const UserEmailPasswordSignInDocument = gql`
  mutation userEmailPasswordSignIn($input: UserEmailPasswordSignInInput!) {
    userEmailPasswordSignIn(input: $input) {
      errors
      redirectPath
    }
  }
`
export type UserEmailPasswordSignInMutationFn = Apollo.MutationFunction<
  UserEmailPasswordSignInMutation,
  UserEmailPasswordSignInMutationVariables
>

/**
 * __useUserEmailPasswordSignInMutation__
 *
 * To run a mutation, you first call `useUserEmailPasswordSignInMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailPasswordSignInMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailPasswordSignInMutation, { data, loading, error }] = useUserEmailPasswordSignInMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserEmailPasswordSignInMutation(
  baseOptions?: Apollo.MutationHookOptions<UserEmailPasswordSignInMutation, UserEmailPasswordSignInMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserEmailPasswordSignInMutation, UserEmailPasswordSignInMutationVariables>(
    UserEmailPasswordSignInDocument,
    options
  )
}
export type UserEmailPasswordSignInMutationHookResult = ReturnType<typeof useUserEmailPasswordSignInMutation>
export type UserEmailPasswordSignInMutationResult = Apollo.MutationResult<UserEmailPasswordSignInMutation>
export type UserEmailPasswordSignInMutationOptions = Apollo.BaseMutationOptions<
  UserEmailPasswordSignInMutation,
  UserEmailPasswordSignInMutationVariables
>
export const GetFederatedIdentitySessionDocument = gql`
  query GetFederatedIdentitySession {
    federatedIdentitySession {
      hasSession
      webid
      name
      provider
    }
  }
`

/**
 * __useGetFederatedIdentitySessionQuery__
 *
 * To run a query within a React component, call `useGetFederatedIdentitySessionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFederatedIdentitySessionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFederatedIdentitySessionQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetFederatedIdentitySessionQuery(
  baseOptions?: Apollo.QueryHookOptions<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>(
    GetFederatedIdentitySessionDocument,
    options
  )
}
export function useGetFederatedIdentitySessionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetFederatedIdentitySessionQuery, GetFederatedIdentitySessionQueryVariables>(
    GetFederatedIdentitySessionDocument,
    options
  )
}
export type GetFederatedIdentitySessionQueryHookResult = ReturnType<typeof useGetFederatedIdentitySessionQuery>
export type GetFederatedIdentitySessionLazyQueryHookResult = ReturnType<typeof useGetFederatedIdentitySessionLazyQuery>
export type GetFederatedIdentitySessionQueryResult = Apollo.QueryResult<
  GetFederatedIdentitySessionQuery,
  GetFederatedIdentitySessionQueryVariables
>
export const UserCreateDocument = gql`
  mutation userCreate($input: UserCreateInput!) {
    userCreate(input: $input) {
      errors
      redirectPath
      isUserActive
    }
  }
`
export type UserCreateMutationFn = Apollo.MutationFunction<UserCreateMutation, UserCreateMutationVariables>

/**
 * __useUserCreateMutation__
 *
 * To run a mutation, you first call `useUserCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userCreateMutation, { data, loading, error }] = useUserCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserCreateMutation(baseOptions?: Apollo.MutationHookOptions<UserCreateMutation, UserCreateMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserCreateMutation, UserCreateMutationVariables>(UserCreateDocument, options)
}
export type UserCreateMutationHookResult = ReturnType<typeof useUserCreateMutation>
export type UserCreateMutationResult = Apollo.MutationResult<UserCreateMutation>
export type UserCreateMutationOptions = Apollo.BaseMutationOptions<UserCreateMutation, UserCreateMutationVariables>
export const UserConfirmationEmailResendDocument = gql`
  mutation userConfirmationEmailResend($input: UserConfirmationEmailResendInput!) {
    userConfirmationEmailResend(input: $input) {
      errors
    }
  }
`
export type UserConfirmationEmailResendMutationFn = Apollo.MutationFunction<
  UserConfirmationEmailResendMutation,
  UserConfirmationEmailResendMutationVariables
>

/**
 * __useUserConfirmationEmailResendMutation__
 *
 * To run a mutation, you first call `useUserConfirmationEmailResendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserConfirmationEmailResendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userConfirmationEmailResendMutation, { data, loading, error }] = useUserConfirmationEmailResendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserConfirmationEmailResendMutation(
  baseOptions?: Apollo.MutationHookOptions<UserConfirmationEmailResendMutation, UserConfirmationEmailResendMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserConfirmationEmailResendMutation, UserConfirmationEmailResendMutationVariables>(
    UserConfirmationEmailResendDocument,
    options
  )
}
export type UserConfirmationEmailResendMutationHookResult = ReturnType<typeof useUserConfirmationEmailResendMutation>
export type UserConfirmationEmailResendMutationResult = Apollo.MutationResult<UserConfirmationEmailResendMutation>
export type UserConfirmationEmailResendMutationOptions = Apollo.BaseMutationOptions<
  UserConfirmationEmailResendMutation,
  UserConfirmationEmailResendMutationVariables
>
export const QueryWebidAvailableFromWsDocument = gql`
  query QueryWebidAvailableFromWS($webid: String!) {
    webidAvailable(webid: $webid)
  }
`

/**
 * __useQueryWebidAvailableFromWsQuery__
 *
 * To run a query within a React component, call `useQueryWebidAvailableFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryWebidAvailableFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryWebidAvailableFromWsQuery({
 *   variables: {
 *      webid: // value for 'webid'
 *   },
 * });
 */
export function useQueryWebidAvailableFromWsQuery(
  baseOptions: Apollo.QueryHookOptions<QueryWebidAvailableFromWsQuery, QueryWebidAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QueryWebidAvailableFromWsQuery, QueryWebidAvailableFromWsQueryVariables>(
    QueryWebidAvailableFromWsDocument,
    options
  )
}
export function useQueryWebidAvailableFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QueryWebidAvailableFromWsQuery, QueryWebidAvailableFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QueryWebidAvailableFromWsQuery, QueryWebidAvailableFromWsQueryVariables>(
    QueryWebidAvailableFromWsDocument,
    options
  )
}
export type QueryWebidAvailableFromWsQueryHookResult = ReturnType<typeof useQueryWebidAvailableFromWsQuery>
export type QueryWebidAvailableFromWsLazyQueryHookResult = ReturnType<typeof useQueryWebidAvailableFromWsLazyQuery>
export type QueryWebidAvailableFromWsQueryResult = Apollo.QueryResult<
  QueryWebidAvailableFromWsQuery,
  QueryWebidAvailableFromWsQueryVariables
>
export const GetAvailableLocalesFromWsDocument = gql`
  query GetAvailableLocalesFromWS {
    metadata {
      id
      availableLocales {
        label
        value
      }
    }
  }
`

/**
 * __useGetAvailableLocalesFromWsQuery__
 *
 * To run a query within a React component, call `useGetAvailableLocalesFromWsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAvailableLocalesFromWsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAvailableLocalesFromWsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAvailableLocalesFromWsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetAvailableLocalesFromWsQuery, GetAvailableLocalesFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAvailableLocalesFromWsQuery, GetAvailableLocalesFromWsQueryVariables>(
    GetAvailableLocalesFromWsDocument,
    options
  )
}
export function useGetAvailableLocalesFromWsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetAvailableLocalesFromWsQuery, GetAvailableLocalesFromWsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetAvailableLocalesFromWsQuery, GetAvailableLocalesFromWsQueryVariables>(
    GetAvailableLocalesFromWsDocument,
    options
  )
}
export type GetAvailableLocalesFromWsQueryHookResult = ReturnType<typeof useGetAvailableLocalesFromWsQuery>
export type GetAvailableLocalesFromWsLazyQueryHookResult = ReturnType<typeof useGetAvailableLocalesFromWsLazyQuery>
export type GetAvailableLocalesFromWsQueryResult = Apollo.QueryResult<
  GetAvailableLocalesFromWsQuery,
  GetAvailableLocalesFromWsQueryVariables
>
export const GetPodsDocument = gql`
  query GetPods {
    pods {
      webid
      name
      avatar
    }
  }
`

/**
 * __useGetPodsQuery__
 *
 * To run a query within a React component, call `useGetPodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPodsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPodsQuery(baseOptions?: Apollo.QueryHookOptions<GetPodsQuery, GetPodsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPodsQuery, GetPodsQueryVariables>(GetPodsDocument, options)
}
export function useGetPodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPodsQuery, GetPodsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPodsQuery, GetPodsQueryVariables>(GetPodsDocument, options)
}
export type GetPodsQueryHookResult = ReturnType<typeof useGetPodsQuery>
export type GetPodsLazyQueryHookResult = ReturnType<typeof useGetPodsLazyQuery>
export type GetPodsQueryResult = Apollo.QueryResult<GetPodsQuery, GetPodsQueryVariables>
