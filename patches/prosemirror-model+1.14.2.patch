diff --git a/node_modules/prosemirror-model/dist/index.es.js b/node_modules/prosemirror-model/dist/index.es.js
index b1626f4..5a674aa 100644
--- a/node_modules/prosemirror-model/dist/index.es.js
+++ b/node_modules/prosemirror-model/dist/index.es.js
@@ -1,4 +1,5 @@
 import OrderedMap from 'orderedmap';
+import { v4 as uuid } from 'uuid';
 
 function findDiffStart(a, b, pos) {
   for (var i = 0;; i++) {
@@ -1014,7 +1015,7 @@ var Node = function Node(type, attrs, content, marks) {
   // An object mapping attribute names to values. The kind of
   // attributes allowed and required are
   // [determined](#model.NodeSpec.attrs) by the node type.
-  this.attrs = attrs;
+  this.attrs = {uuid: uuid(), sort: 0, ...attrs};
 
   // :: Fragment
   // A container holding the node's children.
@@ -1375,6 +1376,11 @@ Object.defineProperties( Node.prototype, prototypeAccessors$3 );
 
 var TextNode = /*@__PURE__*/(function (Node) {
   function TextNode(type, attrs, content, marks) {
+    if (attrs && !attrs.keepUuid) {
+      delete attrs.uuid
+      delete attrs.sort
+    }
+    delete attrs?.keepUuid;
     Node.call(this, type, attrs, null, marks);
 
     if (!content) { throw new RangeError("Empty text nodes are not allowed") }
@@ -1865,6 +1871,13 @@ function computeAttrs(attrs, value) {
     }
     built[name] = given;
   }
+  if (value?.uuid) {
+    built.uuid = value.uuid
+  }
+  if (value?.sort) {
+    built.sort = value.sort
+  }
+  
   return built
 }
 
@@ -2372,7 +2385,19 @@ Schema.prototype.node = function node (type, attrs, content, marks) {
 // allowed.
 Schema.prototype.text = function text (text$1, marks) {
   var type = this.nodes.text;
-  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))
+  var attrs = type.defaultAttrs
+  if(text$1.startsWith("uuid$$$$")){
+    attrs.uuid = text$1.slice(8, 44)
+    attrs.keepUuid = true
+    text$1 = text$1.slice(44)
+  }
+  if(text$1.startsWith("sort$$$$")){ 
+    text$1 = text$1.slice(8)
+    var split_result = text$1.split("####")
+    attrs.sort = parseInt(split_result[0])
+    text$1 = split_result.slice(1).join("####")
+  }
+  return new TextNode(type, attrs, text$1, Mark.setFrom(marks))
 };
 
 // :: (union<string, MarkType>, ?Object) â†’ Mark
