# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/unparser/all/unparser.rbi
#
# unparser-0.6.5

module Unparser
  def self.buffer(source, identification = nil); end
  def self.parse(source); end
  def self.parse_either(source); end
  def self.parse_with_comments(source); end
  def self.parser; end
  def self.unparse(node, comment_array = nil); end
  def self.unparse_either(node); end
  def self.unparse_validate(node, comment_array = nil); end
end
class Unparser::Equalizer < Module
  def define_cmp_method; end
  def define_hash_method; end
  def define_inspect_method; end
  def define_methods; end
  def included(descendant); end
  def initialize(*keys); end
end
module Unparser::Equalizer::Methods
  def ==(other); end
  def eql?(other); end
end
module Unparser::Adamantium
  def self.included(descendant); end
end
module Unparser::Adamantium::InstanceMethods
  def dup; end
  def freeze; end
  def memoized_method_cache; end
end
class Unparser::Adamantium::Memory
  def fetch(name); end
  def initialize(values); end
end
module Unparser::Adamantium::ClassMethods
  def new(*arg0); end
end
module Unparser::Adamantium::ModuleMethods
  def memoize(*methods); end
  def memoize_method(method_name); end
  def memoized?(method_name); end
  def memoized_methods; end
  def unmemoized_instance_method(method_name); end
end
class Unparser::Adamantium::MethodBuilder
  def assert_arity(arity); end
  def call; end
  def create_memoized_method; end
  def initialize(descendant, method_name); end
  def remove_original_method; end
  def set_method_visibility; end
  def visibility; end
end
class Unparser::Adamantium::MethodBuilder::InvalidArityError < ArgumentError
  def initialize(descendant, method, arity); end
end
class Unparser::Adamantium::MethodBuilder::BlockNotAllowedError < ArgumentError
  def initialize(descendant, method); end
end
module Unparser::AbstractType
  def self.create_new_method(abstract_class); end
  def self.included(descendant); end
end
module Unparser::AbstractType::AbstractMethodDeclarations
  def abstract_method(*names); end
  def abstract_singleton_method(*names); end
  def create_abstract_instance_method(name); end
  def create_abstract_singleton_method(name); end
end
class Unparser::Concord < Module
  def define_equalizer; end
  def define_initialize; end
  def define_readers; end
  def initialize(*names); end
  def instance_variable_names; end
  def names; end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Equalizer::Methods
end
class Unparser::Concord::Public < Unparser::Concord
  def included(descendant); end
end
module Unparser::RequireBlock
  def require_block; end
end
class Unparser::Either
  def left?; end
  def right?; end
  def self.wrap_error(*exceptions); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
end
class Unparser::Either::Left < Unparser::Either
  def bind(&block); end
  def either(left, _right); end
  def fmap(&block); end
  def from_left; end
  def from_right; end
  def lmap; end
end
class Unparser::Either::Right < Unparser::Either
  def bind; end
  def either(_left, right); end
  def fmap; end
  def from_left; end
  def from_right; end
  def lmap(&block); end
end
class Unparser::Anima < Module
  def add(*names); end
  def assert_known_attributes(klass, attribute_hash); end
  def attribute_names(&block); end
  def attributes; end
  def attributes_hash(object); end
  def included(descendant); end
  def initialize(*names); end
  def initialize_instance(object, attribute_hash); end
  def new(attributes); end
  def remove(*names); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Equalizer::Methods
end
module Unparser::Anima::InstanceMethods
  def initialize(attributes); end
  def to_h; end
  def with(attributes); end
end
class Unparser::Anima::Attribute
  def get(object); end
  def initialize(name); end
  def instance_variable_name; end
  def load(object, attributes); end
  def name; end
  def set(object, value); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Equalizer::Methods
end
class Unparser::Anima::Error < RuntimeError
  def initialize(klass, missing, unknown); end
end
module Unparser::NodeHelpers
  def n(type, children = nil); end
  def n?(type, node); end
  def n_arg?(node); end
  def n_args?(node); end
  def n_array?(node); end
  def n_array_pattern?(node); end
  def n_begin?(node); end
  def n_block?(node); end
  def n_cbase?(node); end
  def n_const?(node); end
  def n_dstr?(node); end
  def n_empty_else?(node); end
  def n_ensure?(node); end
  def n_hash?(node); end
  def n_hash_pattern?(node); end
  def n_if?(node); end
  def n_in_pattern?(node); end
  def n_int?(node); end
  def n_kwarg?(node); end
  def n_kwargs?(node); end
  def n_kwsplat?(node); end
  def n_lambda?(node); end
  def n_match_rest?(node); end
  def n_pair?(node); end
  def n_rescue?(node); end
  def n_send?(node); end
  def n_shadowarg?(node); end
  def n_splat?(node); end
  def n_str?(node); end
  def n_sym?(node); end
  def s(type, *children); end
  def unwrap_single_begin(node); end
end
module Unparser::AST
  def self.local_variable_assignments(node); end
  def self.local_variable_reads(node); end
  def self.not_close_scope?(node); end
  def self.not_reset_scope?(node); end
end
class Unparser::AST::Enumerator
  def each(&block); end
  def self.new(node, controller = nil); end
  def self.set(enumerable); end
  def self.type(node, type); end
  def type(type); end
  def types(types); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
end
class Unparser::AST::Walker
  def call(node); end
  def self.call(node, controller = nil, &block); end
  include Anonymous_Unparser_Concord_47
end
module Anonymous_Unparser_Concord_47
  def block; end
  def controller; end
  def initialize(*args); end
  include Anonymous_Unparser_Equalizer_48
  include Unparser::Equalizer::Methods
end
module Anonymous_Unparser_Equalizer_48
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::AST::LocalVariableScope
  def first_assignment?(node); end
  def first_assignment_in?(left, right); end
  def initialize(node); end
  def local_variable_defined_for_node?(node, name); end
  def match(needle); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Enumerable
  include Unparser::Adamantium::InstanceMethods
end
class Unparser::AST::LocalVariableScopeEnumerator
  def current; end
  def define(name); end
  def each(node, &block); end
  def enter(node); end
  def initialize; end
  def leave(node); end
  def pop; end
  def push_inherit; end
  def push_reset; end
  def self.each(node, &block); end
  def visit(node, &block); end
  include Enumerable
end
class Unparser::Buffer
  def append(string); end
  def append_without_prefix(string); end
  def capture_content; end
  def content; end
  def fresh_line?; end
  def indent; end
  def initialize; end
  def nl; end
  def prefix; end
  def root_indent; end
  def unindent; end
  def write(fragment); end
end
module Unparser::Generation
  def children; end
  def conditional_parentheses(flag, &block); end
  def delimited(nodes, delimiter = nil, &block); end
  def emit_body(node, indent: nil); end
  def emit_body_ensure_rescue(node); end
  def emit_body_inner(node); end
  def emit_body_member(node); end
  def emit_body_rescue(node); end
  def emit_comments(comments); end
  def emit_comments_before(source_part = nil); end
  def emit_ensure(node); end
  def emit_eof_comments; end
  def emit_eol_comments; end
  def emit_heredoc_reminders; end
  def emit_join(nodes, emit_node, emit_delimiter); end
  def emit_optional_body(node, indent: nil); end
  def emit_optional_body_ensure_rescue(node); end
  def emit_rescue_postcontrol(node); end
  def emit_rescue_regular(node); end
  def emitter(node); end
  def first_child; end
  def indented; end
  def k_end; end
  def nl; end
  def parentheses(open = nil, close = nil); end
  def symbol_name; end
  def visit(node); end
  def visit_deep(node); end
  def with_comments; end
  def write(*strings); end
  def write_to_buffer; end
  def writer_with(klass, node); end
  def ws; end
end
class Unparser::Color
  def format(text); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
end
class Unparser::Comments
  def consume(node, source_part = nil); end
  def initialize(comments); end
  def self.source_range(node, part); end
  def source_range(*arguments); end
  def take_all; end
  def take_before(node, source_part); end
  def take_eol_comments; end
  def take_up_to_line(line); end
  def take_while; end
  def unshift_documents(comments); end
end
module Unparser::Constants
end
class Unparser::Diff
  def colorized_diff(&block); end
  def diff(&block); end
  def diffs; end
  def hunks; end
  def max_length; end
  def minimized_hunk; end
  def self.build(old, new); end
  def self.colorize_line(line); end
  def self.lines(source); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
end
module Unparser::DSL
  def children(*names); end
  def define_child(name, index); end
  def define_group(name, range); end
  def define_remaining_children(names); end
end
class Unparser::UnknownNodeError < ArgumentError
end
class Unparser::Emitter
  def buffer; end
  def comments; end
  def dispatch(*arg0); end
  def emit_mlhs; end
  def local_variable_scope; end
  def node; end
  def node_type; end
  def self.anima; end
  def self.emitter(buffer:, comments:, node:, local_variable_scope:); end
  def self.handle(*types); end
  def self.new(*args, &block); end
  extend Unparser::AbstractType::AbstractMethodDeclarations
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  extend Unparser::DSL
  include Anonymous_Unparser_Anima_50
  include Anonymous_Unparser_Equalizer_49
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Anima::InstanceMethods
  include Unparser::Equalizer::Methods
end
module Anonymous_Unparser_Anima_50
end
module Anonymous_Unparser_Equalizer_49
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Unparser::Emitter::LocalVariableRoot
  def local_variable_scope; end
  def self.included(descendant); end
end
class Unparser::Emitter::Alias < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def source; end
  def target; end
end
class Unparser::Emitter::Args < Unparser::Emitter
  def emit_block_arguments; end
  def emit_def_arguments; end
  def emit_lambda_arguments; end
  def emit_shadowargs; end
  def normal_arguments(&block); end
  def shadowargs(&block); end
end
class Unparser::Emitter::Morearg < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::Optarg < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  def value; end
end
class Unparser::Emitter::KeywordOptional < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  def value; end
end
class Unparser::Emitter::Kwarg < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::Restarg < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::Argument < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::Procarg < Unparser::Emitter
  def dispatch; end
  def needs_parens?; end
end
class Unparser::Emitter::BlockPass < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::Array < Unparser::Emitter
  def dispatch; end
  def emit_heredoc_reminders; end
  def emitters(&block); end
end
class Unparser::Emitter::ArrayPattern < Unparser::Emitter
  def dispatch; end
  def emit_member(node); end
end
class Unparser::Emitter::Assignment < Unparser::Emitter
  def dispatch; end
  def emit_heredoc_reminders; end
  def emit_left(*arg0); end
  def emit_right; end
  def symbol_name; end
end
class Unparser::Emitter::Assignment::Variable < Unparser::Emitter::Assignment
  def emit_left; end
  def name; end
  def remaining_children; end
  def right; end
end
class Unparser::Emitter::Assignment::Constant < Unparser::Emitter::Assignment
  def base; end
  def emit_left; end
  def name; end
  def remaining_children; end
  def right; end
end
class Unparser::Emitter::Begin < Unparser::Emitter
  def body; end
  def dispatch; end
  def emit_heredoc_reminders; end
  def remaining_children; end
end
class Unparser::Emitter::Binary < Unparser::Emitter
  def dispatch; end
  def writer(&block); end
end
class Unparser::Emitter::Block < Unparser::Emitter
  def arguments; end
  def body; end
  def dispatch; end
  def emit_block_arguments; end
  def emit_lambda_arguments; end
  def emit_send_target; end
  def emit_target; end
  def need_do?; end
  def numblock?; end
  def remaining_children; end
  def target; end
  def target_writer(&block); end
  def write_close; end
  def write_open; end
end
class Unparser::Emitter::Case < Unparser::Emitter
  def condition; end
  def dispatch; end
  def emit_condition; end
  def emit_else; end
  def emit_whens; end
  def remaining_children; end
  def whens(&block); end
end
class Unparser::Emitter::When < Unparser::Emitter
  def captures(&block); end
  def dispatch; end
  def emit_captures; end
end
class Unparser::Emitter::CaseGuard < Unparser::Emitter
  def condition; end
  def dispatch; end
  def remaining_children; end
end
class Unparser::Emitter::CaseMatch < Unparser::Emitter
  def dispatch; end
  def else_branch; end
  def emit_else_branch; end
  def patterns(&block); end
  def remaining_children; end
  def target; end
end
class Unparser::Emitter::CBase < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::Class < Unparser::Emitter
  def body; end
  def dispatch; end
  def emit_superclass; end
  def local_variable_scope(&block); end
  def name; end
  def remaining_children; end
  def superclass; end
  include Unparser::Emitter::LocalVariableRoot
end
class Unparser::Emitter::SClass < Unparser::Emitter
  def body; end
  def dispatch; end
  def object; end
  def remaining_children; end
end
class Unparser::Emitter::ConstPattern < Unparser::Emitter
  def const; end
  def dispatch; end
  def pattern; end
  def remaining_children; end
end
class Unparser::Emitter::Def < Unparser::Emitter
  def body(*arg0); end
  def dispatch; end
  def emit_arguments; end
  def emit_name(*arg0); end
  def local_variable_scope(&block); end
  include Unparser::Emitter::LocalVariableRoot
end
class Unparser::Emitter::Def::Instance < Unparser::Emitter::Def
  def arguments; end
  def body; end
  def emit_name; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::Def::Singleton < Unparser::Emitter::Def
  def arguments; end
  def body; end
  def emit_name; end
  def name; end
  def remaining_children; end
  def subject; end
  def subject_without_parens?; end
end
class Unparser::Emitter::Defined < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def subject; end
end
class Unparser::Emitter::DStr < Unparser::Emitter
  def dispatch; end
  def emit_heredoc_reminders; end
end
class Unparser::Emitter::DSym < Unparser::Emitter
  def dispatch; end
  def emit_begin_child(component); end
  def emit_str_child(value); end
end
class Unparser::Emitter::FlipFlop < Unparser::Emitter
  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
  def symbol_name; end
end
class Unparser::Emitter::Float < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def value; end
end
class Unparser::Emitter::FlowModifier < Unparser::Emitter
  def dispatch; end
  def emit_arguments; end
  def emit_heredoc_reminders; end
end
class Unparser::Emitter::For < Unparser::Emitter
  def assignment; end
  def body; end
  def condition; end
  def dispatch; end
  def emit_condition; end
  def remaining_children; end
end
class Unparser::Emitter::Hash < Unparser::Emitter
  def dispatch; end
  def emit_hash_body; end
  def emit_heredoc_reminder_member(node); end
  def emit_heredoc_reminders; end
  def emit_last_argument_hash; end
end
class Unparser::Emitter::HashPattern < Unparser::Emitter
  def dispatch; end
  def emit_const_pattern; end
  def emit_hash_body; end
  def emit_match_var(node); end
  def emit_member(node); end
  def emit_pair(node); end
  def write_symbol_body(symbol); end
end
class Unparser::Emitter::Hookexe < Unparser::Emitter
  def body; end
  def dispatch; end
  def remaining_children; end
end
class Unparser::Emitter::If < Unparser::Emitter
  def condition; end
  def dispatch; end
  def else_branch; end
  def emit_condition; end
  def emit_else_branch; end
  def emit_if_branch; end
  def emit_normal; end
  def emit_postcondition; end
  def emit_ternary; end
  def if_branch; end
  def keyword; end
  def postcondition?; end
  def remaining_children; end
  def unless?; end
end
class Unparser::Emitter::InMatch < Unparser::Emitter
  def dispatch; end
  def pattern; end
  def remaining_children; end
  def target; end
end
class Unparser::Emitter::InPattern < Unparser::Emitter
  def branch; end
  def dispatch; end
  def else_branch; end
  def remaining_children; end
  def target; end
  def unless_guard; end
end
class Unparser::Emitter::Index < Unparser::Emitter
  def dispatch; end
  def emit_receiver; end
end
class Unparser::Emitter::Index::Reference < Unparser::Emitter::Index
  def emit_operation; end
  def indices(&block); end
end
class Unparser::Emitter::Index::Assign < Unparser::Emitter::Index
  def dispatch; end
  def emit_heredoc_reminders; end
  def emit_mlhs; end
  def emit_operation(indices); end
end
class Unparser::Emitter::KWBegin < Unparser::Emitter
  def dispatch; end
  def emit_multiple_body; end
end
class Unparser::Emitter::Lambda < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::MASGN < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def source; end
  def target; end
end
class Unparser::Emitter::Match < Unparser::Emitter
end
class Unparser::Emitter::Match::Lvasgn < Unparser::Emitter::Match
  def dispatch; end
  def lvasgn; end
  def regexp; end
  def remaining_children; end
end
class Unparser::Emitter::Match::CurrentLine < Unparser::Emitter::Match
  def dispatch; end
  def regexp; end
  def remaining_children; end
end
class Unparser::Emitter::MatchAlt < Unparser::Emitter
  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
end
class Unparser::Emitter::MatchAs < Unparser::Emitter
  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
end
class Unparser::Emitter::MatchRest < Unparser::Emitter
  def dispatch; end
  def emit_array_pattern; end
  def emit_hash_pattern; end
  def emit_match_var; end
  def match_var; end
  def remaining_children; end
end
class Unparser::Emitter::MatchVar < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::MLHS < Unparser::Emitter
  def dispatch; end
  def emit_many; end
  def emit_one_child_mlhs; end
end
class Unparser::Emitter::Module < Unparser::Emitter
  def body; end
  def dispatch; end
  def local_variable_scope(&block); end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::LocalVariableRoot
end
class Unparser::Emitter::BinaryAssign < Unparser::Emitter
  def dispatch; end
  def emit_heredoc_reminders; end
  def expression; end
  def remaining_children; end
  def target; end
end
class Unparser::Emitter::OpAssign < Unparser::Emitter
  def dispatch; end
  def emit_operator; end
  def operator; end
  def remaining_children; end
  def target; end
  def value; end
end
class Unparser::Emitter::Pin < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def target; end
end
class Unparser::Emitter::Primitive < Unparser::Emitter
  def remaining_children; end
  def value; end
end
class Unparser::Emitter::Primitive::Inspect < Unparser::Emitter::Primitive
  def dispatch; end
end
class Unparser::Emitter::Primitive::Complex < Unparser::Emitter::Primitive
  def dispatch; end
  def emit_imaginary; end
  def imaginary_node; end
end
class Unparser::Emitter::Primitive::Rational < Unparser::Emitter::Primitive
  def dispatch; end
  def write_rational(value); end
end
class Unparser::Emitter::Primitive::Numeric < Unparser::Emitter::Primitive
  def dispatch; end
end
class Unparser::Emitter::Range < Unparser::Emitter
  def begin_node; end
  def dispatch; end
  def end_node; end
  def remaining_children; end
  def symbol_name; end
end
class Unparser::Emitter::Regexp < Unparser::Emitter
  def body(&block); end
  def dispatch; end
  def emit_body(node); end
  def emit_options; end
end
class Unparser::Emitter::Post < Unparser::Emitter
  def body; end
  def condition; end
  def dispatch; end
  def remaining_children; end
end
class Unparser::Emitter::Repetition < Unparser::Emitter
  def body; end
  def condition; end
  def dispatch; end
  def emit_keyword; end
  def emit_normal; end
  def emit_postcontrol; end
  def postcontrol?; end
  def remaining_children; end
end
class Unparser::Emitter::Rescue < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::Root < Unparser::Emitter
  def buffer; end
  def comments; end
  def dispatch; end
  def local_variable_scope(&block); end
  def node; end
  include Anonymous_Unparser_Concord_Public_51
  include Unparser::Emitter::LocalVariableRoot
end
module Anonymous_Unparser_Concord_Public_51
  def buffer; end
  def comments; end
  def initialize(*args); end
  def node; end
  include Anonymous_Unparser_Equalizer_52
  include Unparser::Equalizer::Methods
end
module Anonymous_Unparser_Equalizer_52
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Emitter::Send < Unparser::Emitter
  def dispatch; end
  def emit_heredoc_reminders; end
  def emit_mlhs; end
  def writer(&block); end
end
class Unparser::Emitter::Simple < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::KwSplat < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def subject; end
end
class Unparser::Emitter::Splat < Unparser::Emitter
  def dispatch; end
  def emit_mlhs; end
  def remaining_children; end
  def subject; end
  def subject_emitter(&block); end
end
class Unparser::Emitter::Super < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::Undef < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::Variable < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::Const < Unparser::Emitter
  def dispatch; end
  def emit_scope; end
  def name; end
  def remaining_children; end
  def scope; end
end
class Unparser::Emitter::NthRef < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::XStr < Unparser::Emitter
  def dispatch; end
  def emit_begin(component); end
  def emit_heredoc; end
  def emit_string(value); end
  def emit_xstr; end
  def escape_xstr(input); end
  def heredoc?; end
end
class Unparser::Emitter::Yield < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::Kwargs < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::Pair < Unparser::Emitter
  def colon?(key); end
  def dispatch; end
  def key; end
  def remaining_children; end
  def value; end
end
class Unparser::Emitter::FindPattern < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::MatchPattern < Unparser::Emitter
  def dispatch; end
  def pattern; end
  def remaining_children; end
  def target; end
end
class Unparser::Emitter::MatchPatternP < Unparser::Emitter
  def dispatch; end
  def pattern; end
  def remaining_children; end
  def target; end
end
module Unparser::Writer
  def self.included(descendant); end
  include Unparser::Generation
end
class Unparser::Writer::Binary
  def buffer; end
  def comments; end
  def dispatch; end
  def effective_symbol; end
  def emit_operator; end
  def emit_with(map); end
  def keyword_symbol; end
  def left; end
  def left_emitter(&block); end
  def local_variable_scope; end
  def node; end
  def operator_symbol; end
  def remaining_children; end
  def right; end
  def right_emitter(&block); end
  def self.anima; end
  def symbol_name; end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  extend Unparser::DSL
  include Anonymous_Unparser_Anima_54
  include Anonymous_Unparser_Equalizer_53
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Anima::InstanceMethods
  include Unparser::Equalizer::Methods
  include Unparser::Writer
end
module Anonymous_Unparser_Anima_54
end
module Anonymous_Unparser_Equalizer_53
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Writer::DynamicString
  def breakpoint?(child, current); end
  def buffer; end
  def classify(node); end
  def classify_str(node); end
  def comments; end
  def dispatch; end
  def emit_body(children); end
  def emit_dstr; end
  def emit_dynamic(child); end
  def emit_dynamic_component(node); end
  def emit_heredoc_body; end
  def emit_heredoc_footer; end
  def emit_heredoc_header; end
  def emit_heredoc_reminder; end
  def emit_normal_heredoc_body; end
  def emit_segment(children, index); end
  def emit_squiggly_heredoc_body; end
  def escape_dynamic(string); end
  def heredoc?; end
  def heredoc_header; end
  def heredoc_pattern?; end
  def heredoc_pattern_2?; end
  def heredoc_pattern_3?; end
  def local_variable_scope; end
  def nl_last_child?; end
  def node; end
  def segments; end
  def self.anima; end
  def str_empty?(node); end
  def str_nl?(node); end
  def str_ws?(node); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  extend Unparser::DSL
  include Anonymous_Unparser_Anima_56
  include Anonymous_Unparser_Equalizer_55
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Anima::InstanceMethods
  include Unparser::Equalizer::Methods
  include Unparser::Writer
end
module Anonymous_Unparser_Anima_56
end
module Anonymous_Unparser_Equalizer_55
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Writer::Resbody
  def assignment; end
  def body; end
  def buffer; end
  def comments; end
  def emit_assignment; end
  def emit_exception; end
  def emit_postcontrol; end
  def emit_regular; end
  def exception; end
  def local_variable_scope; end
  def node; end
  def remaining_children; end
  def self.anima; end
  extend Unparser::DSL
  include Anonymous_Unparser_Anima_58
  include Anonymous_Unparser_Equalizer_57
  include Unparser::Anima::InstanceMethods
  include Unparser::Equalizer::Methods
  include Unparser::Writer
end
module Anonymous_Unparser_Anima_58
end
module Anonymous_Unparser_Equalizer_57
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Writer::Rescue
  def body; end
  def buffer; end
  def comments; end
  def else_node; end
  def emit_heredoc_reminders; end
  def emit_postcontrol; end
  def emit_regular; end
  def emit_rescue_body(node); end
  def local_variable_scope; end
  def node; end
  def remaining_children; end
  def rescue_bodies(&block); end
  def rescue_body; end
  def self.anima; end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  extend Unparser::DSL
  include Anonymous_Unparser_Anima_60
  include Anonymous_Unparser_Equalizer_59
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Anima::InstanceMethods
  include Unparser::Equalizer::Methods
  include Unparser::Writer
end
module Anonymous_Unparser_Anima_60
end
module Anonymous_Unparser_Equalizer_59
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Writer::Send
  def arguments; end
  def avoid_clash?; end
  def buffer; end
  def comments; end
  def details(&block); end
  def dispatch; end
  def effective_writer(&block); end
  def effective_writer_class; end
  def emit_arguments; end
  def emit_heredoc_reminder(argument); end
  def emit_heredoc_reminders; end
  def emit_mlhs; end
  def emit_normal_arguments; end
  def emit_operator; end
  def emit_selector; end
  def emit_send_regular(node); end
  def local_variable_clash?; end
  def local_variable_scope; end
  def node; end
  def parses_as_constant?; end
  def receiver; end
  def remaining_children; end
  def selector; end
  def self.anima; end
  def write_as_attribute_assignment?; end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  extend Unparser::DSL
  include Anonymous_Unparser_Anima_62
  include Anonymous_Unparser_Equalizer_61
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Anima::InstanceMethods
  include Unparser::Equalizer::Methods
  include Unparser::Writer
end
module Anonymous_Unparser_Anima_62
end
module Anonymous_Unparser_Equalizer_61
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Writer::Send::AttributeAssignment < Unparser::Writer::Send
  def dispatch; end
  def emit_attribute; end
  def emit_receiver; end
  def emit_send_mlhs; end
  def first_argument; end
  def receiver; end
  def remaining_children; end
  def selector; end
end
class Unparser::Writer::Send::Binary < Unparser::Writer::Send
  def dispatch; end
  def emit_operator; end
  def emit_right; end
end
class Unparser::Writer::Send::Regular < Unparser::Writer::Send
  def dispatch; end
  def emit_arguments_without_heredoc_body; end
  def emit_receiver; end
  def emit_send_mlhs; end
end
class Unparser::Writer::Send::Unary < Unparser::Writer::Send
  def dispatch; end
end
module Unparser::NodeDetails
  def children; end
  def self.included(descendant); end
  include Unparser::Constants
end
class Unparser::NodeDetails::Send
  def arguments(&block); end
  def arguments?; end
  def assignment?(&block); end
  def assignment_operator?; end
  def binary_syntax_allowed?; end
  def non_assignment_selector; end
  def receiver; end
  def remaining_children; end
  def selector; end
  def selector_binary_operator?; end
  def selector_unary_operator?; end
  def string_selector(&block); end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  extend Unparser::DSL
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
  include Unparser::NodeDetails
end
class Unparser::CLI
  def add_options(builder); end
  def effective_targets; end
  def exit_status; end
  def initialize(arguments); end
  def process_target(target); end
  def self.run(*arguments); end
  def targets(file_name); end
end
class Unparser::CLI::Target
  def self.new(*args, &block); end
  extend Unparser::AbstractType::AbstractMethodDeclarations
  include Unparser::AbstractType
end
class Unparser::CLI::Target::Path < Unparser::CLI::Target
  def literal_validation; end
  def validation; end
  include Anonymous_Unparser_Concord_63
end
module Anonymous_Unparser_Concord_63
  def initialize(*args); end
  def path; end
  include Anonymous_Unparser_Equalizer_64
  include Unparser::Equalizer::Methods
end
module Anonymous_Unparser_Equalizer_64
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::CLI::Target::String
  def literal_validation; end
  def validation; end
  include Anonymous_Unparser_Concord_65
end
module Anonymous_Unparser_Concord_65
  def initialize(*args); end
  def string; end
  include Anonymous_Unparser_Equalizer_66
  include Unparser::Equalizer::Methods
end
module Anonymous_Unparser_Equalizer_66
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Validation
  def generated_node; end
  def generated_source; end
  def identification; end
  def make_report(label, attribute_name); end
  def node_diff_report; end
  def original_node; end
  def original_source; end
  def report(&block); end
  def report_exception(exception); end
  def self.anima; end
  def self.const_unit(_value); end
  def self.from_node(original_node); end
  def self.from_path(path); end
  def self.from_string(original_source); end
  def success?; end
  extend Unparser::Adamantium::ClassMethods
  extend Unparser::Adamantium::ModuleMethods
  include Anonymous_Unparser_Equalizer_67
  include Unparser::Adamantium
  include Unparser::Adamantium::InstanceMethods
  include Unparser::Anima::InstanceMethods
  include Unparser::Equalizer::Methods
end
module Anonymous_Unparser_Equalizer_67
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Validation::Literal < Unparser::Validation
  def report; end
  def source_diff_report; end
  def success?; end
end
class Unparser::Builder < Parser::Builders::Default
  def initialize; end
end
class Unparser::InvalidNodeError < RuntimeError
  def initialize(message, node); end
  def node; end
end
